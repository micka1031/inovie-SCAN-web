{"ast":null,"code":"import React,{createContext,useContext,useState,useEffect}from'react';import{SELASService}from'../services/SELASService';import{useAuth}from'./AuthContext';// Interface pour le contexte\nimport{jsx as _jsx}from\"react/jsx-runtime\";// Création du contexte avec des valeurs par défaut\nconst SelasContext=/*#__PURE__*/createContext({currentSelasId:null,setCurrentSelasId:()=>{},availableSelas:[],loading:false,error:null});// Hook pour utiliser le contexte dans les composants\nexport const useSelasContext=()=>useContext(SelasContext);// Props pour le provider\n// Provider du contexte\nexport const SelasProvider=_ref=>{let{children}=_ref;const[currentSelasId,setCurrentSelasIdState]=useState(localStorage.getItem('currentSelasId'));const[availableSelas,setAvailableSelas]=useState([]);const[loading,setLoading]=useState(false);const[error,setError]=useState(null);const{currentUser}=useAuth();// Charger la liste des SELAS disponibles uniquement si l'utilisateur est authentifié\nuseEffect(()=>{const fetchSelas=async()=>{// Si l'utilisateur n'est pas authentifié, ne rien faire\nif(!currentUser){setAvailableSelas([]);setLoading(false);return;}try{setLoading(true);const selasService=SELASService.getInstance();const selasData=await selasService.getSELAS();// Filtrer uniquement les SELAS actives\nconst activeSelas=selasData.filter(sela=>sela.active);setAvailableSelas(activeSelas);// Si aucune SELAS active n'est trouvée\nif(activeSelas.length===0){console.warn(\"Aucune SELAS active n'a été trouvée!\");setError(\"Aucune SELAS active disponible\");}// Si l'ID SELAS actuel n'est pas dans la liste des SELAS actives\nif(currentSelasId&&!activeSelas.some(sela=>sela.id===currentSelasId)){// Si au moins une SELAS active existe, définir la première comme courante\nif(activeSelas.length>0){setCurrentSelasId(activeSelas[0].id);}else{// Sinon, effacer l'ID SELAS actuel\nsetCurrentSelasId(null);}}// Si aucune SELAS n'est sélectionnée et qu'il en existe au moins une\nif(!currentSelasId&&activeSelas.length>0){setCurrentSelasId(activeSelas[0].id);}}catch(error){console.error('Erreur lors du chargement des SELAS:',error);setError('Erreur lors du chargement des SELAS');}finally{setLoading(false);}};fetchSelas();},[currentSelasId,currentUser]);// Fonction pour définir l'ID SELAS actuel\nconst setCurrentSelasId=id=>{if(id){localStorage.setItem('currentSelasId',id);}else{localStorage.removeItem('currentSelasId');}setCurrentSelasIdState(id);};// Valeur du contexte\nconst value={currentSelasId,setCurrentSelasId,availableSelas,loading,error};return/*#__PURE__*/_jsx(SelasContext.Provider,{value:value,children:children});};export default SelasContext;","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","SELASService","useAuth","jsx","_jsx","SelasContext","currentSelasId","setCurrentSelasId","availableSelas","loading","error","useSelasContext","SelasProvider","_ref","children","setCurrentSelasIdState","localStorage","getItem","setAvailableSelas","setLoading","setError","currentUser","fetchSelas","selasService","getInstance","selasData","getSELAS","activeSelas","filter","sela","active","length","console","warn","some","id","setItem","removeItem","value","Provider"],"sources":["C:/Users/LS_110/Documents/GitHub/inovie-SCAN-web-main/src/contexts/SelasContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\r\nimport { collection, getDocs, query, where } from 'firebase/firestore';\r\nimport { db } from '../config/firebase';\r\nimport { SELAS } from '../types/SELAS';\r\nimport { SELASService } from '../services/SELASService';\r\nimport { useAuth } from './AuthContext';\r\n\r\n// Interface pour le contexte\r\ninterface SelasContextType {\r\n  currentSelasId: string | null;\r\n  setCurrentSelasId: (id: string | null) => void;\r\n  availableSelas: SELAS[];\r\n  loading: boolean;\r\n  error: string | null;\r\n}\r\n\r\n// Création du contexte avec des valeurs par défaut\r\nconst SelasContext = createContext<SelasContextType>({\r\n  currentSelasId: null,\r\n  setCurrentSelasId: () => {},\r\n  availableSelas: [],\r\n  loading: false,\r\n  error: null\r\n});\r\n\r\n// Hook pour utiliser le contexte dans les composants\r\nexport const useSelasContext = () => useContext(SelasContext);\r\n\r\n// Props pour le provider\r\ninterface SelasProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n// Provider du contexte\r\nexport const SelasProvider: React.FC<SelasProviderProps> = ({ children }) => {\r\n  const [currentSelasId, setCurrentSelasIdState] = useState<string | null>(\r\n    localStorage.getItem('currentSelasId')\r\n  );\r\n  const [availableSelas, setAvailableSelas] = useState<SELAS[]>([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { currentUser } = useAuth();\r\n  \r\n  // Charger la liste des SELAS disponibles uniquement si l'utilisateur est authentifié\r\n  useEffect(() => {\r\n    const fetchSelas = async () => {\r\n      // Si l'utilisateur n'est pas authentifié, ne rien faire\r\n      if (!currentUser) {\r\n        setAvailableSelas([]);\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        setLoading(true);\r\n        const selasService = SELASService.getInstance();\r\n        const selasData = await selasService.getSELAS();\r\n        \r\n        // Filtrer uniquement les SELAS actives\r\n        const activeSelas = selasData.filter(sela => sela.active);\r\n        setAvailableSelas(activeSelas);\r\n        \r\n        // Si aucune SELAS active n'est trouvée\r\n        if (activeSelas.length === 0) {\r\n          console.warn(\"Aucune SELAS active n'a été trouvée!\");\r\n          setError(\"Aucune SELAS active disponible\");\r\n        }\r\n        \r\n        // Si l'ID SELAS actuel n'est pas dans la liste des SELAS actives\r\n        if (currentSelasId && !activeSelas.some(sela => sela.id === currentSelasId)) {\r\n          // Si au moins une SELAS active existe, définir la première comme courante\r\n          if (activeSelas.length > 0) {\r\n            setCurrentSelasId(activeSelas[0].id);\r\n          } else {\r\n            // Sinon, effacer l'ID SELAS actuel\r\n            setCurrentSelasId(null);\r\n          }\r\n        }\r\n        \r\n        // Si aucune SELAS n'est sélectionnée et qu'il en existe au moins une\r\n        if (!currentSelasId && activeSelas.length > 0) {\r\n          setCurrentSelasId(activeSelas[0].id);\r\n        }\r\n        \r\n      } catch (error) {\r\n        console.error('Erreur lors du chargement des SELAS:', error);\r\n        setError('Erreur lors du chargement des SELAS');\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n    \r\n    fetchSelas();\r\n  }, [currentSelasId, currentUser]);\r\n  \r\n  // Fonction pour définir l'ID SELAS actuel\r\n  const setCurrentSelasId = (id: string | null) => {\r\n    if (id) {\r\n      localStorage.setItem('currentSelasId', id);\r\n    } else {\r\n      localStorage.removeItem('currentSelasId');\r\n    }\r\n    setCurrentSelasIdState(id);\r\n  };\r\n  \r\n  // Valeur du contexte\r\n  const value = {\r\n    currentSelasId,\r\n    setCurrentSelasId,\r\n    availableSelas,\r\n    loading,\r\n    error\r\n  };\r\n  \r\n  return (\r\n    <SelasContext.Provider value={value}>\r\n      {children}\r\n    </SelasContext.Provider>\r\n  );\r\n};\r\n\r\nexport default SelasContext; \r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}