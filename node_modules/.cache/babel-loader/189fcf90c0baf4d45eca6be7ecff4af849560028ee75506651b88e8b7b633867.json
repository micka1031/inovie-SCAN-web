{"ast":null,"code":"/**\n * Utilitaires pour le géocodage des adresses\n */\n\n// Cache pour stocker les résultats de géocodage\nconst geocodeCache = {};\n\n// Clé API Mapbox (à remplacer par votre propre clé)\n// Vous devez créer un compte sur https://www.mapbox.com/ et obtenir une clé API\nconst MAPBOX_API_KEY = 'pk.eyJ1IjoiaW5vdmllLXN1aXZpLWNvbGlzIiwiYSI6ImNsZXh0ZjRhbzBpNXgzcG1yNGt2NWt0bXcifQ.HVEFXKCGsmXM-pZ6HA3tYA';\n\n// Fonction pour valider les données d'adresse\nconst isValidAddress = (adresse, ville, codePostal) => {\n  // Vérifier que les champs ne sont pas vides ou composés uniquement d'espaces\n  if (!(adresse !== null && adresse !== void 0 && adresse.trim()) || !(ville !== null && ville !== void 0 && ville.trim()) || !(codePostal !== null && codePostal !== void 0 && codePostal.trim())) {\n    return false;\n  }\n\n  // Vérifier que les champs ne contiennent pas des valeurs invalides\n  const invalidValues = ['END', 'UNDEFINED', 'NULL', 'N/A', 'RDC', ''];\n  const fieldsToCheck = [adresse.toUpperCase(), ville.toUpperCase(), codePostal.toUpperCase()];\n\n  // Vérifier si un des champs contient uniquement des valeurs invalides\n  return !fieldsToCheck.some(field => {\n    const parts = field.split(/[,\\s]+/).map(part => part.trim());\n    return parts.length === 0 || parts.every(part => invalidValues.includes(part));\n  });\n};\n\n/**\n * Nettoie et normalise une adresse\n * @param address Adresse à nettoyer\n * @returns Adresse nettoyée\n */\nconst cleanAddress = address => {\n  if (!address) return '';\n\n  // Supprimer les mentions inutiles\n  const cleanedAddress = address.replace(/\\b(rdc|rez[- ]de[- ]chauss[ée]e)\\b/gi, '') // Supprimer RDC/Rez-de-chaussée\n  .replace(/\\b(bat|bât|batiment|bâtiment)\\b\\.?\\s*([0-9a-z])/gi, 'Bâtiment $2') // Normaliser \"bâtiment\"\n  .replace(/\\b(apt|appt|appartement)\\b\\.?\\s*([0-9a-z])/gi, 'Appartement $2') // Normaliser \"appartement\"\n  .replace(/\\s+/g, ' ') // Remplacer les espaces multiples par un seul espace\n  .trim();\n  return cleanedAddress;\n};\n\n/**\n * Normalise un nom de lieu pour le géocodage\n * @param name Nom du lieu à normaliser\n * @returns Nom normalisé\n */\nconst normalizeLocationName = name => {\n  if (!name) return '';\n\n  // Normaliser les caractères spéciaux et la casse\n  let normalized = name.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase().trim();\n\n  // Remplacer les abréviations courantes\n  const replacements = {\n    'via domitia': 'voie domitienne',\n    'zac': 'zone d\\'activité',\n    'zi': 'zone industrielle',\n    'za': 'zone artisanale',\n    'rdc': '',\n    'rez de chaussee': '',\n    'rez-de-chaussee': ''\n  };\n\n  // Appliquer les remplacements\n  Object.entries(replacements).forEach(([pattern, replacement]) => {\n    normalized = normalized.replace(new RegExp(`\\\\b${pattern}\\\\b`, 'g'), replacement);\n  });\n  return normalized.trim();\n};\n\n/**\n * Géocode une adresse avec l'API Nominatim d'OpenStreetMap\n * @param fullAddress Adresse complète à géocoder\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nconst geocodeWithNominatim = async fullAddress => {\n  try {\n    console.log('Tentative de géocodage avec Nominatim pour:', fullAddress);\n\n    // Ajouter un User-Agent pour respecter les conditions d'utilisation de Nominatim\n    const headers = {\n      'User-Agent': 'InovieSuiviColis/1.0',\n      'Accept-Language': 'fr'\n    };\n\n    // Utiliser l'API Nominatim d'OpenStreetMap pour le géocodage\n    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullAddress)}&limit=1&addressdetails=1&countrycodes=fr`, {\n      headers\n    });\n    if (!response.ok) {\n      throw new Error(`Erreur HTTP: ${response.status}`);\n    }\n    const data = await response.json();\n    if (data && data.length > 0) {\n      const latitude = parseFloat(data[0].lat);\n      const longitude = parseFloat(data[0].lon);\n\n      // Validation supplémentaire des coordonnées\n      if (isNaN(latitude) || isNaN(longitude)) {\n        console.warn('Coordonnées invalides pour Nominatim:', {\n          fullAddress,\n          rawData: data[0],\n          latitude,\n          longitude\n        });\n        return null;\n      }\n\n      // Vérification de la plage de coordonnées pour la France\n      if (latitude < 41 || latitude > 51 || longitude < -5 || longitude > 9) {\n        console.warn('Coordonnées hors de la zone France pour Nominatim:', {\n          fullAddress,\n          latitude,\n          longitude\n        });\n        return null;\n      }\n      console.log('Géocodage réussi avec Nominatim pour:', {\n        fullAddress,\n        latitude,\n        longitude,\n        precision: data[0].type || 'inconnu'\n      });\n      return {\n        latitude,\n        longitude\n      };\n    }\n    console.log('Géocodage échoué avec Nominatim pour:', fullAddress);\n    return null;\n  } catch (error) {\n    console.error('Erreur lors du géocodage avec Nominatim:', error);\n    return null;\n  }\n};\n\n/**\n * Géocode une adresse avec l'API Mapbox\n * @param fullAddress Adresse complète à géocoder\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nconst geocodeWithMapbox = async fullAddress => {\n  try {\n    console.log('Tentative de géocodage avec Mapbox pour:', fullAddress);\n\n    // Utiliser l'API Mapbox pour le géocodage\n    const response = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(fullAddress)}.json?access_token=${MAPBOX_API_KEY}&country=fr&limit=1&language=fr`);\n    if (!response.ok) {\n      throw new Error(`Erreur HTTP: ${response.status}`);\n    }\n    const data = await response.json();\n    if (data && data.features && data.features.length > 0) {\n      const coordinates = data.features[0].center;\n      const longitude = coordinates[0];\n      const latitude = coordinates[1];\n\n      // Validation supplémentaire des coordonnées\n      if (isNaN(latitude) || isNaN(longitude)) {\n        console.warn('Coordonnées invalides pour Mapbox:', {\n          fullAddress,\n          rawData: data.features[0],\n          latitude,\n          longitude\n        });\n        return null;\n      }\n\n      // Vérification de la plage de coordonnées pour la France\n      if (latitude < 41 || latitude > 51 || longitude < -5 || longitude > 9) {\n        console.warn('Coordonnées hors de la zone France pour Mapbox:', {\n          fullAddress,\n          latitude,\n          longitude\n        });\n        return null;\n      }\n      console.log('Géocodage réussi avec Mapbox pour:', {\n        fullAddress,\n        latitude,\n        longitude,\n        precision: data.features[0].place_type ? data.features[0].place_type[0] : 'inconnu'\n      });\n      return {\n        // Mapbox retourne les coordonnées au format [longitude, latitude]\n        longitude,\n        latitude\n      };\n    }\n    console.log('Géocodage échoué avec Mapbox pour:', fullAddress);\n    return null;\n  } catch (error) {\n    console.error('Erreur lors du géocodage avec Mapbox:', error);\n    return null;\n  }\n};\n\n/**\n * Géocode une adresse pour obtenir ses coordonnées géographiques\n * @param name Nom du site\n * @param address Adresse (rue, numéro)\n * @param city Ville\n * @param postalCode Code postal\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nexport const geocodeAddress = async (name, address, city, postalCode) => {\n  try {\n    // Nettoyer les données d'entrée\n    const cleanedAddress = cleanAddress(address);\n    const cleanedCity = city === null || city === void 0 ? void 0 : city.trim();\n    const cleanedPostalCode = postalCode === null || postalCode === void 0 ? void 0 : postalCode.trim();\n\n    // Valider les données avant de procéder\n    if (!isValidAddress(cleanedAddress, cleanedCity, cleanedPostalCode)) {\n      console.warn('Géocodage impossible - Données d\\'adresse invalides:', {\n        name,\n        address: cleanedAddress,\n        city: cleanedCity,\n        postalCode: cleanedPostalCode\n      });\n      return null;\n    }\n\n    // Construire l'adresse complète SANS le nom du site\n    const addressParts = [cleanedAddress, cleanedCity, cleanedPostalCode, 'France'].filter(part => part && typeof part === 'string' && part.trim() !== '');\n    const fullAddress = addressParts.join(', ');\n\n    // Logs détaillés pour le débogage\n    console.log('Détails du géocodage:', {\n      originalAddress: address,\n      cleanedAddress,\n      originalCity: city,\n      cleanedCity,\n      originalPostalCode: postalCode,\n      cleanedPostalCode,\n      fullAddress,\n      addressParts\n    });\n\n    // Vérifier si l'adresse est déjà dans le cache\n    const cacheKey = fullAddress.toLowerCase();\n    if (geocodeCache[cacheKey] !== undefined) {\n      console.log('Utilisation du cache pour:', fullAddress);\n      return geocodeCache[cacheKey];\n    }\n\n    // Essayer d'abord avec Nominatim\n    let result = await geocodeWithNominatim(fullAddress);\n\n    // Si Nominatim échoue, essayer avec Mapbox\n    if (!result) {\n      console.log('Nominatim a échoué, tentative avec Mapbox...');\n      result = await geocodeWithMapbox(fullAddress);\n    }\n\n    // Si les deux API échouent, essayer avec une adresse simplifiée\n    if (!result) {\n      console.log('Tentative avec adresse simplifiée...');\n      const simpleAddress = [cleanedCity, cleanedPostalCode, 'France'].filter(part => part && typeof part === 'string' && part.trim() !== '').join(', ');\n      console.log('Adresse simplifiée:', simpleAddress);\n\n      // Vérifier si l'adresse simplifiée est déjà dans le cache\n      const simpleCacheKey = simpleAddress.toLowerCase();\n      if (geocodeCache[simpleCacheKey] !== undefined) {\n        console.log('Utilisation du cache pour adresse simplifiée:', simpleAddress);\n        result = geocodeCache[simpleCacheKey];\n      } else {\n        // Essayer d'abord avec Nominatim\n        result = await geocodeWithNominatim(simpleAddress);\n\n        // Si Nominatim échoue, essayer avec Mapbox\n        if (!result) {\n          console.log('Nominatim a échoué pour l\\'adresse simplifiée, tentative avec Mapbox...');\n          result = await geocodeWithMapbox(simpleAddress);\n        }\n\n        // Stocker le résultat dans le cache pour l'adresse simplifiée\n        if (result) {\n          geocodeCache[simpleCacheKey] = result;\n        }\n      }\n    }\n\n    // Stocker le résultat dans le cache pour l'adresse complète\n    if (result) {\n      geocodeCache[cacheKey] = result;\n    } else {\n      console.warn('Géocodage impossible pour le site:', {\n        name,\n        fullAddress,\n        address: cleanedAddress,\n        city: cleanedCity,\n        postalCode: cleanedPostalCode\n      });\n    }\n    return result;\n  } catch (error) {\n    console.error('Erreur lors du géocodage:', error);\n    return null;\n  }\n};\n\n/**\n * Géocode une adresse complète pour obtenir ses coordonnées géographiques\n * @param fullAddress Adresse complète\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nexport const geocodeFullAddress = async fullAddress => {\n  try {\n    // Vérifier si l'adresse est déjà dans le cache\n    const cacheKey = fullAddress.toLowerCase();\n    if (geocodeCache[cacheKey] !== undefined) {\n      console.log('Utilisation du cache pour:', fullAddress);\n      return geocodeCache[cacheKey];\n    }\n\n    // Essayer d'abord avec Nominatim\n    let result = await geocodeWithNominatim(fullAddress);\n\n    // Si Nominatim échoue, essayer avec Mapbox\n    if (!result) {\n      console.log('Nominatim a échoué, tentative avec Mapbox...');\n      result = await geocodeWithMapbox(fullAddress);\n    }\n\n    // Stocker le résultat dans le cache\n    geocodeCache[cacheKey] = result;\n    return result;\n  } catch (error) {\n    console.error('Erreur lors du géocodage:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["geocodeCache","MAPBOX_API_KEY","isValidAddress","adresse","ville","codePostal","trim","invalidValues","fieldsToCheck","toUpperCase","some","field","parts","split","map","part","length","every","includes","cleanAddress","address","cleanedAddress","replace","normalizeLocationName","name","normalized","normalize","toLowerCase","replacements","Object","entries","forEach","pattern","replacement","RegExp","geocodeWithNominatim","fullAddress","console","log","headers","response","fetch","encodeURIComponent","ok","Error","status","data","json","latitude","parseFloat","lat","longitude","lon","isNaN","warn","rawData","precision","type","error","geocodeWithMapbox","features","coordinates","center","place_type","geocodeAddress","city","postalCode","cleanedCity","cleanedPostalCode","addressParts","filter","join","originalAddress","originalCity","originalPostalCode","cacheKey","undefined","result","simpleAddress","simpleCacheKey","geocodeFullAddress"],"sources":["C:/Users/LS_110/Documents/GitHub/inovie-SCAN-web-main/src/utils/geocoding.ts"],"sourcesContent":["/**\n * Utilitaires pour le géocodage des adresses\n */\n\n// Cache pour stocker les résultats de géocodage\nconst geocodeCache: Record<string, {latitude: number, longitude: number} | null> = {};\n\n// Clé API Mapbox (à remplacer par votre propre clé)\n// Vous devez créer un compte sur https://www.mapbox.com/ et obtenir une clé API\nconst MAPBOX_API_KEY = 'pk.eyJ1IjoiaW5vdmllLXN1aXZpLWNvbGlzIiwiYSI6ImNsZXh0ZjRhbzBpNXgzcG1yNGt2NWt0bXcifQ.HVEFXKCGsmXM-pZ6HA3tYA';\n\n// Fonction pour valider les données d'adresse\nconst isValidAddress = (adresse: string, ville: string, codePostal: string): boolean => {\n  // Vérifier que les champs ne sont pas vides ou composés uniquement d'espaces\n  if (!adresse?.trim() || !ville?.trim() || !codePostal?.trim()) {\n    return false;\n  }\n\n  // Vérifier que les champs ne contiennent pas des valeurs invalides\n  const invalidValues = ['END', 'UNDEFINED', 'NULL', 'N/A', 'RDC', ''];\n  const fieldsToCheck = [adresse.toUpperCase(), ville.toUpperCase(), codePostal.toUpperCase()];\n  \n  // Vérifier si un des champs contient uniquement des valeurs invalides\n  return !fieldsToCheck.some(field => {\n    const parts = field.split(/[,\\s]+/).map(part => part.trim());\n    return parts.length === 0 || parts.every(part => invalidValues.includes(part));\n  });\n};\n\n/**\n * Nettoie et normalise une adresse\n * @param address Adresse à nettoyer\n * @returns Adresse nettoyée\n */\nconst cleanAddress = (address: string): string => {\n  if (!address) return '';\n  \n  // Supprimer les mentions inutiles\n  const cleanedAddress = address\n    .replace(/\\b(rdc|rez[- ]de[- ]chauss[ée]e)\\b/gi, '')  // Supprimer RDC/Rez-de-chaussée\n    .replace(/\\b(bat|bât|batiment|bâtiment)\\b\\.?\\s*([0-9a-z])/gi, 'Bâtiment $2')  // Normaliser \"bâtiment\"\n    .replace(/\\b(apt|appt|appartement)\\b\\.?\\s*([0-9a-z])/gi, 'Appartement $2')  // Normaliser \"appartement\"\n    .replace(/\\s+/g, ' ')  // Remplacer les espaces multiples par un seul espace\n    .trim();\n    \n  return cleanedAddress;\n};\n\n/**\n * Normalise un nom de lieu pour le géocodage\n * @param name Nom du lieu à normaliser\n * @returns Nom normalisé\n */\nconst normalizeLocationName = (name: string): string => {\n  if (!name) return '';\n  \n  // Normaliser les caractères spéciaux et la casse\n  let normalized = name\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toLowerCase()\n    .trim();\n  \n  // Remplacer les abréviations courantes\n  const replacements: Record<string, string> = {\n    'via domitia': 'voie domitienne',\n    'zac': 'zone d\\'activité',\n    'zi': 'zone industrielle',\n    'za': 'zone artisanale',\n    'rdc': '',\n    'rez de chaussee': '',\n    'rez-de-chaussee': ''\n  };\n  \n  // Appliquer les remplacements\n  Object.entries(replacements).forEach(([pattern, replacement]) => {\n    normalized = normalized.replace(new RegExp(`\\\\b${pattern}\\\\b`, 'g'), replacement);\n  });\n  \n  return normalized.trim();\n};\n\n/**\n * Géocode une adresse avec l'API Nominatim d'OpenStreetMap\n * @param fullAddress Adresse complète à géocoder\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nconst geocodeWithNominatim = async (\n  fullAddress: string\n): Promise<{latitude: number, longitude: number} | null> => {\n  try {\n    console.log('Tentative de géocodage avec Nominatim pour:', fullAddress);\n    \n    // Ajouter un User-Agent pour respecter les conditions d'utilisation de Nominatim\n    const headers = {\n      'User-Agent': 'InovieSuiviColis/1.0',\n      'Accept-Language': 'fr'\n    };\n    \n    // Utiliser l'API Nominatim d'OpenStreetMap pour le géocodage\n    const response = await fetch(\n      `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullAddress)}&limit=1&addressdetails=1&countrycodes=fr`,\n      { headers }\n    );\n    \n    if (!response.ok) {\n      throw new Error(`Erreur HTTP: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    if (data && data.length > 0) {\n      const latitude = parseFloat(data[0].lat);\n      const longitude = parseFloat(data[0].lon);\n      \n      // Validation supplémentaire des coordonnées\n      if (isNaN(latitude) || isNaN(longitude)) {\n        console.warn('Coordonnées invalides pour Nominatim:', { \n          fullAddress, \n          rawData: data[0],\n          latitude, \n          longitude \n        });\n        return null;\n      }\n      \n      // Vérification de la plage de coordonnées pour la France\n      if (\n        latitude < 41 || latitude > 51 || \n        longitude < -5 || longitude > 9\n      ) {\n        console.warn('Coordonnées hors de la zone France pour Nominatim:', { \n          fullAddress, \n          latitude, \n          longitude \n        });\n        return null;\n      }\n      \n      console.log('Géocodage réussi avec Nominatim pour:', {\n        fullAddress,\n        latitude,\n        longitude,\n        precision: data[0].type || 'inconnu'\n      });\n      \n      return { latitude, longitude };\n    }\n    \n    console.log('Géocodage échoué avec Nominatim pour:', fullAddress);\n    return null;\n  } catch (error) {\n    console.error('Erreur lors du géocodage avec Nominatim:', error);\n    return null;\n  }\n};\n\n/**\n * Géocode une adresse avec l'API Mapbox\n * @param fullAddress Adresse complète à géocoder\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nconst geocodeWithMapbox = async (\n  fullAddress: string\n): Promise<{latitude: number, longitude: number} | null> => {\n  try {\n    console.log('Tentative de géocodage avec Mapbox pour:', fullAddress);\n    \n    // Utiliser l'API Mapbox pour le géocodage\n    const response = await fetch(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(fullAddress)}.json?access_token=${MAPBOX_API_KEY}&country=fr&limit=1&language=fr`\n    );\n    \n    if (!response.ok) {\n      throw new Error(`Erreur HTTP: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    if (data && data.features && data.features.length > 0) {\n      const coordinates = data.features[0].center;\n      const longitude = coordinates[0];\n      const latitude = coordinates[1];\n      \n      // Validation supplémentaire des coordonnées\n      if (isNaN(latitude) || isNaN(longitude)) {\n        console.warn('Coordonnées invalides pour Mapbox:', { \n          fullAddress, \n          rawData: data.features[0],\n          latitude, \n          longitude \n        });\n        return null;\n      }\n      \n      // Vérification de la plage de coordonnées pour la France\n      if (\n        latitude < 41 || latitude > 51 || \n        longitude < -5 || longitude > 9\n      ) {\n        console.warn('Coordonnées hors de la zone France pour Mapbox:', { \n          fullAddress, \n          latitude, \n          longitude \n        });\n        return null;\n      }\n      \n      console.log('Géocodage réussi avec Mapbox pour:', {\n        fullAddress,\n        latitude,\n        longitude,\n        precision: data.features[0].place_type ? data.features[0].place_type[0] : 'inconnu'\n      });\n      \n      return {\n        // Mapbox retourne les coordonnées au format [longitude, latitude]\n        longitude,\n        latitude\n      };\n    }\n    \n    console.log('Géocodage échoué avec Mapbox pour:', fullAddress);\n    return null;\n  } catch (error) {\n    console.error('Erreur lors du géocodage avec Mapbox:', error);\n    return null;\n  }\n};\n\n/**\n * Géocode une adresse pour obtenir ses coordonnées géographiques\n * @param name Nom du site\n * @param address Adresse (rue, numéro)\n * @param city Ville\n * @param postalCode Code postal\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nexport const geocodeAddress = async (\n  name: string,\n  address: string, \n  city: string, \n  postalCode: string\n): Promise<{latitude: number, longitude: number} | null> => {\n  try {\n    // Nettoyer les données d'entrée\n    const cleanedAddress = cleanAddress(address);\n    const cleanedCity = city?.trim();\n    const cleanedPostalCode = postalCode?.trim();\n    \n    // Valider les données avant de procéder\n    if (!isValidAddress(cleanedAddress, cleanedCity, cleanedPostalCode)) {\n      console.warn('Géocodage impossible - Données d\\'adresse invalides:', { \n        name,\n        address: cleanedAddress, \n        city: cleanedCity, \n        postalCode: cleanedPostalCode \n      });\n      return null;\n    }\n\n    // Construire l'adresse complète SANS le nom du site\n    const addressParts = [\n      cleanedAddress,\n      cleanedCity,\n      cleanedPostalCode,\n      'France'\n    ].filter(part => part && typeof part === 'string' && part.trim() !== '');\n\n    const fullAddress = addressParts.join(', ');\n    \n    // Logs détaillés pour le débogage\n    console.log('Détails du géocodage:', {\n      originalAddress: address,\n      cleanedAddress,\n      originalCity: city,\n      cleanedCity,\n      originalPostalCode: postalCode,\n      cleanedPostalCode,\n      fullAddress,\n      addressParts\n    });\n    \n    // Vérifier si l'adresse est déjà dans le cache\n    const cacheKey = fullAddress.toLowerCase();\n    if (geocodeCache[cacheKey] !== undefined) {\n      console.log('Utilisation du cache pour:', fullAddress);\n      return geocodeCache[cacheKey];\n    }\n    \n    // Essayer d'abord avec Nominatim\n    let result = await geocodeWithNominatim(fullAddress);\n    \n    // Si Nominatim échoue, essayer avec Mapbox\n    if (!result) {\n      console.log('Nominatim a échoué, tentative avec Mapbox...');\n      result = await geocodeWithMapbox(fullAddress);\n    }\n    \n    // Si les deux API échouent, essayer avec une adresse simplifiée\n    if (!result) {\n      console.log('Tentative avec adresse simplifiée...');\n      const simpleAddress = [cleanedCity, cleanedPostalCode, 'France']\n        .filter(part => part && typeof part === 'string' && part.trim() !== '')\n        .join(', ');\n      \n      console.log('Adresse simplifiée:', simpleAddress);\n      \n      // Vérifier si l'adresse simplifiée est déjà dans le cache\n      const simpleCacheKey = simpleAddress.toLowerCase();\n      if (geocodeCache[simpleCacheKey] !== undefined) {\n        console.log('Utilisation du cache pour adresse simplifiée:', simpleAddress);\n        result = geocodeCache[simpleCacheKey];\n      } else {\n        // Essayer d'abord avec Nominatim\n        result = await geocodeWithNominatim(simpleAddress);\n        \n        // Si Nominatim échoue, essayer avec Mapbox\n        if (!result) {\n          console.log('Nominatim a échoué pour l\\'adresse simplifiée, tentative avec Mapbox...');\n          result = await geocodeWithMapbox(simpleAddress);\n        }\n        \n        // Stocker le résultat dans le cache pour l'adresse simplifiée\n        if (result) {\n          geocodeCache[simpleCacheKey] = result;\n        }\n      }\n    }\n    \n    // Stocker le résultat dans le cache pour l'adresse complète\n    if (result) {\n      geocodeCache[cacheKey] = result;\n    } else {\n      console.warn('Géocodage impossible pour le site:', { \n        name,\n        fullAddress,\n        address: cleanedAddress, \n        city: cleanedCity, \n        postalCode: cleanedPostalCode \n      });\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Erreur lors du géocodage:', error);\n    return null;\n  }\n};\n\n/**\n * Géocode une adresse complète pour obtenir ses coordonnées géographiques\n * @param fullAddress Adresse complète\n * @returns Coordonnées géographiques (latitude, longitude) ou null si le géocodage échoue\n */\nexport const geocodeFullAddress = async (\n  fullAddress: string\n): Promise<{latitude: number, longitude: number} | null> => {\n  try {\n    // Vérifier si l'adresse est déjà dans le cache\n    const cacheKey = fullAddress.toLowerCase();\n    if (geocodeCache[cacheKey] !== undefined) {\n      console.log('Utilisation du cache pour:', fullAddress);\n      return geocodeCache[cacheKey];\n    }\n    \n    // Essayer d'abord avec Nominatim\n    let result = await geocodeWithNominatim(fullAddress);\n    \n    // Si Nominatim échoue, essayer avec Mapbox\n    if (!result) {\n      console.log('Nominatim a échoué, tentative avec Mapbox...');\n      result = await geocodeWithMapbox(fullAddress);\n    }\n    \n    // Stocker le résultat dans le cache\n    geocodeCache[cacheKey] = result;\n    \n    return result;\n  } catch (error) {\n    console.error('Erreur lors du géocodage:', error);\n    return null;\n  }\n}; \r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}