{"ast":null,"code":"import{db}from'../config/firebase';import{collection,getDocs,Timestamp,doc,writeBatch}from'firebase/firestore';import JSZip from'jszip';/**\n * Service pour gérer l'intégration entre Firebase et SharePoint\n * Utilise une approche de synchronisation manuelle via fichiers CSV/JSON\n * pour contourner les limitations de double authentification\n */export class SharePointService{constructor(){// Collections Firebase à synchroniser\nthis.collections=['passages','sites','tournees','vehicules'];}/**\n   * Exporte les données d'une collection Firebase au format CSV\n   * @param collectionName Nom de la collection à exporter\n   * @returns Chaîne de caractères au format CSV\n   */async exportCollectionToCSV(collectionName){try{console.log(`🔄 Exportation de la collection ${collectionName} au format CSV...`);// Récupérer les données de la collection\nconst querySnapshot=await getDocs(collection(db,collectionName));if(querySnapshot.empty){console.log(`⚠️ La collection ${collectionName} est vide.`);return'';}// Extraire les données\nconst documents=querySnapshot.docs.map(doc=>{const data=doc.data();// Convertir les Timestamp en chaînes de caractères\nconst formattedData={};Object.entries(data).forEach(_ref=>{let[key,value]=_ref;if(value instanceof Timestamp){formattedData[key]=value.toDate().toISOString();}else{formattedData[key]=value;}});// Ajouter l'ID du document\nformattedData.id=doc.id;return formattedData;});// Obtenir toutes les clés uniques pour les en-têtes CSV\nconst allKeys=new Set();documents.forEach(doc=>{Object.keys(doc).forEach(key=>allKeys.add(key));});const headers=Array.from(allKeys);// Générer le CSV\nlet csv=headers.join(',')+'\\n';documents.forEach(doc=>{const row=headers.map(header=>{const value=doc[header];// Échapper les valeurs contenant des virgules ou des sauts de ligne\nif(value===undefined||value===null){return'';}else if(typeof value==='string'&&(value.includes(',')||value.includes('\\n')||value.includes('\"'))){return`\"${value.replace(/\"/g,'\"\"')}\"`;}else{return value;}});csv+=row.join(',')+'\\n';});console.log(`✅ Exportation de ${documents.length} documents de la collection ${collectionName} terminée.`);return csv;}catch(error){console.error(`❌ Erreur lors de l'exportation de la collection ${collectionName}:`,error);throw error;}}/**\n   * Exporte les données d'une collection Firebase au format JSON\n   * @param collectionName Nom de la collection à exporter\n   * @returns Objet JSON contenant les données\n   */async exportCollectionToJSON(collectionName){try{console.log(`🔄 Exportation de la collection ${collectionName} au format JSON...`);// Récupérer les données de la collection\nconst querySnapshot=await getDocs(collection(db,collectionName));if(querySnapshot.empty){console.log(`⚠️ La collection ${collectionName} est vide.`);return[];}// Extraire les données\nconst documents=querySnapshot.docs.map(doc=>{const data=doc.data();// Convertir les Timestamp en chaînes de caractères\nconst formattedData={};Object.entries(data).forEach(_ref2=>{let[key,value]=_ref2;if(value instanceof Timestamp){formattedData[key]=value.toDate().toISOString();}else{formattedData[key]=value;}});// Ajouter l'ID du document\nformattedData.id=doc.id;return formattedData;});console.log(`✅ Exportation de ${documents.length} documents de la collection ${collectionName} terminée.`);return documents;}catch(error){console.error(`❌ Erreur lors de l'exportation de la collection ${collectionName}:`,error);throw error;}}/**\n   * Télécharge un fichier CSV contenant les données d'une collection\n   * @param collectionName Nom de la collection à exporter\n   */async downloadCollectionAsCSV(collectionName){try{const csv=await this.exportCollectionToCSV(collectionName);if(!csv){console.log(`⚠️ Aucune donnée à exporter pour la collection ${collectionName}.`);return;}// Créer un blob et un lien de téléchargement\nconst blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});const url=URL.createObjectURL(blob);const link=document.createElement('a');link.setAttribute('href',url);link.setAttribute('download',`${collectionName}_${new Date().toISOString().split('T')[0]}.csv`);link.style.visibility='hidden';document.body.appendChild(link);link.click();document.body.removeChild(link);}catch(error){console.error(`❌ Erreur lors du téléchargement de la collection ${collectionName}:`,error);throw error;}}/**\n   * Télécharge un fichier JSON contenant les données d'une collection\n   * @param collectionName Nom de la collection à exporter\n   */async downloadCollectionAsJSON(collectionName){try{const data=await this.exportCollectionToJSON(collectionName);if(!data||data.length===0){console.log(`⚠️ Aucune donnée à exporter pour la collection ${collectionName}.`);return;}// Créer un blob et un lien de téléchargement\nconst blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});const url=URL.createObjectURL(blob);const link=document.createElement('a');link.setAttribute('href',url);link.setAttribute('download',`${collectionName}_${new Date().toISOString().split('T')[0]}.json`);link.style.visibility='hidden';document.body.appendChild(link);link.click();document.body.removeChild(link);}catch(error){console.error(`❌ Erreur lors du téléchargement de la collection ${collectionName}:`,error);throw error;}}/**\n   * Télécharge toutes les collections au format CSV\n   */async downloadAllCollectionsAsCSV(){try{console.log('🔄 Exportation de toutes les collections au format CSV...');for(const collectionName of this.collections){await this.downloadCollectionAsCSV(collectionName);}console.log('✅ Exportation de toutes les collections terminée.');}catch(error){console.error('❌ Erreur lors de l\\'exportation de toutes les collections:',error);throw error;}}/**\n   * Télécharge toutes les collections au format JSON\n   */async downloadAllCollectionsAsJSON(){try{console.log('🔄 Exportation de toutes les collections au format JSON...');for(const collectionName of this.collections){await this.downloadCollectionAsJSON(collectionName);}console.log('✅ Exportation de toutes les collections terminée.');}catch(error){console.error('❌ Erreur lors de l\\'exportation de toutes les collections:',error);throw error;}}/**\n   * Génère un fichier ZIP contenant toutes les collections au format JSON\n   */async generateCompleteBackup(){try{console.log(\"🔄 Génération d'une sauvegarde complète...\");const zip=new JSZip();// Exporter chaque collection\nfor(const collectionName of this.collections){const data=await this.exportCollectionToJSON(collectionName);if(data&&data.length>0){zip.file(`${collectionName}.json`,JSON.stringify(data,null,2));}}// Générer le fichier ZIP\nconst content=await zip.generateAsync({type:'blob'});// Télécharger le fichier\nconst url=URL.createObjectURL(content);const link=document.createElement('a');link.setAttribute('href',url);link.setAttribute('download',`firebase_backup_${new Date().toISOString().split('T')[0]}.zip`);link.style.visibility='hidden';document.body.appendChild(link);link.click();document.body.removeChild(link);console.log('✅ Génération de la sauvegarde complète terminée.');}catch(error){console.error('❌ Erreur lors de la génération de la sauvegarde complète:',error);throw error;}}/**\n   * Importe des données au format CSV vers une collection Firebase\n   * @param collectionName Nom de la collection cible\n   * @param csvContent Contenu du fichier CSV\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */async importCSVToCollection(collectionName,csvContent){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};try{console.log(`🔄 Importation des données CSV vers la collection ${collectionName}...`);// Options par défaut\nconst{clearCollection=false,updateExisting=true,idField='id'}=options;// Vérifier si la collection existe\nif(!this.collections.includes(collectionName)){throw new Error(`La collection ${collectionName} n'est pas valide.`);}// Analyser le CSV\nconst lines=csvContent.split('\\n');if(lines.length<2){throw new Error('Le fichier CSV est vide ou ne contient que des en-têtes.');}// Extraire les en-têtes\nconst headers=this.parseCSVLine(lines[0]);// Préparer les données\nconst documents=[];for(let i=1;i<lines.length;i++){const line=lines[i].trim();if(!line)continue;const values=this.parseCSVLine(line);if(values.length!==headers.length){console.warn(`⚠️ Ligne ${i+1} ignorée: nombre de valeurs incorrect`);continue;}const doc={};for(let j=0;j<headers.length;j++){const header=headers[j];let value=values[j];// Convertir les valeurs en types appropriés\nif(value==='true')value=true;else if(value==='false')value=false;else if(!isNaN(Number(value))&&value!=='')value=Number(value);else if(typeof value==='string'&&(value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/)||value.match(/^\\d{4}-\\d{2}-\\d{2}/))){// Convertir les dates ISO en Timestamp\ntry{value=Timestamp.fromDate(new Date(value));}catch(e){console.warn(`⚠️ Impossible de convertir la date: ${value}`);}}doc[header]=value;}documents.push(doc);}// Vider la collection si demandé\nif(clearCollection){await this.clearCollection(collectionName);}// Importer les documents\nconst totalDocuments=documents.length;let processedCount=0;let importedCount=0;while(processedCount<totalDocuments){// Créer un nouveau lot pour chaque groupe de 500 documents\nconst batch=writeBatch(db);const batchSize=Math.min(500,totalDocuments-processedCount);// Ajouter les documents au lot\nfor(let i=0;i<batchSize;i++){const document=documents[processedCount+i];const docId=document[idField];if(docId&&updateExisting){// Mettre à jour ou créer le document avec l'ID spécifié\nconst docRef=doc(db,collectionName,docId);batch.set(docRef,document);}else{// Créer un nouveau document avec un ID généré\nconst collectionRef=collection(db,collectionName);const newDocRef=doc(collectionRef);batch.set(newDocRef,document);}importedCount++;}// Exécuter le lot\nawait batch.commit();processedCount+=batchSize;console.log(`✅ Lot de ${batchSize} documents importés (${processedCount}/${totalDocuments})`);}console.log(`✅ Importation terminée: ${importedCount} documents importés dans la collection ${collectionName}`);return importedCount;}catch(error){console.error(`❌ Erreur lors de l'importation des données CSV:`,error);throw error;}}/**\n   * Importe des données au format JSON vers une collection Firebase\n   * @param collectionName Nom de la collection cible\n   * @param jsonData Données JSON à importer\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */async importJSONToCollection(collectionName,jsonData){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};try{console.log(`🔄 Importation des données JSON vers la collection ${collectionName}...`);// Options par défaut\nconst{clearCollection=false,updateExisting=true,idField='id'}=options;// Vérifier si la collection existe\nif(!this.collections.includes(collectionName)){throw new Error(`La collection ${collectionName} n'est pas valide.`);}// Vérifier que les données sont un tableau\nif(!Array.isArray(jsonData)){throw new Error('Les données JSON doivent être un tableau d\\'objets.');}// Convertir les dates en Timestamp\nconst documents=jsonData.map(doc=>{const processedDoc={};Object.entries(doc).forEach(_ref3=>{let[key,value]=_ref3;if(typeof value==='string'&&(value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/)||value.match(/^\\d{4}-\\d{2}-\\d{2}/))){// Convertir les dates ISO en Timestamp\ntry{processedDoc[key]=Timestamp.fromDate(new Date(value));}catch(e){console.warn(`⚠️ Impossible de convertir la date: ${value}`);processedDoc[key]=value;}}else{processedDoc[key]=value;}});return processedDoc;});// Vider la collection si demandé\nif(clearCollection){await this.clearCollection(collectionName);}// Importer les documents\nconst totalDocuments=documents.length;let processedCount=0;let importedCount=0;while(processedCount<totalDocuments){// Créer un nouveau lot pour chaque groupe de 500 documents\nconst batch=writeBatch(db);const batchSize=Math.min(500,totalDocuments-processedCount);// Ajouter les documents au lot\nfor(let i=0;i<batchSize;i++){const document=documents[processedCount+i];const docId=document[idField];if(docId&&updateExisting){// Mettre à jour ou créer le document avec l'ID spécifié\nconst docRef=doc(db,collectionName,docId);batch.set(docRef,document);}else{// Créer un nouveau document avec un ID généré\nconst collectionRef=collection(db,collectionName);const newDocRef=doc(collectionRef);batch.set(newDocRef,document);}importedCount++;}// Exécuter le lot\nawait batch.commit();processedCount+=batchSize;console.log(`✅ Lot de ${batchSize} documents importés (${processedCount}/${totalDocuments})`);}console.log(`✅ Importation terminée: ${importedCount} documents importés dans la collection ${collectionName}`);return importedCount;}catch(error){console.error(`❌ Erreur lors de l'importation des données JSON:`,error);throw error;}}/**\n   * Importe des données depuis un fichier ZIP contenant plusieurs collections\n   * @param zipContent Contenu du fichier ZIP\n   * @param options Options d'importation\n   * @returns Nombre de documents importés par collection\n   */async importFromZip(zipContent){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{console.log('🔄 Importation des données depuis le fichier ZIP...');const zip=new JSZip();await zip.loadAsync(zipContent);const results={};// Parcourir les fichiers du ZIP\nfor(const fileName in zip.files){var _fileName$split$pop;if(zip.files[fileName].dir)continue;const fileExt=(_fileName$split$pop=fileName.split('.').pop())===null||_fileName$split$pop===void 0?void 0:_fileName$split$pop.toLowerCase();const collectionName=fileName.split('.')[0];if(!this.collections.includes(collectionName)){console.warn(`⚠️ Collection inconnue ignorée: ${collectionName}`);continue;}const fileContent=await zip.files[fileName].async('string');if(fileExt==='json'){try{const jsonData=JSON.parse(fileContent);const count=await this.importJSONToCollection(collectionName,jsonData,options);results[collectionName]=count;}catch(e){console.error(`❌ Erreur lors de l'importation du fichier JSON ${fileName}:`,e);}}else if(fileExt==='csv'){try{const count=await this.importCSVToCollection(collectionName,fileContent,options);results[collectionName]=count;}catch(e){console.error(`❌ Erreur lors de l'importation du fichier CSV ${fileName}:`,e);}}else{console.warn(`⚠️ Type de fichier non pris en charge: ${fileExt}`);}}console.log('✅ Importation depuis ZIP terminée:',results);return results;}catch(error){console.error('❌ Erreur lors de l\\'importation depuis le fichier ZIP:',error);throw error;}}/**\n   * Vide une collection\n   * @param collectionName Nom de la collection à vider\n   */async clearCollection(collectionName){try{console.log(`🔄 Suppression des documents existants dans la collection ${collectionName}...`);const collectionRef=collection(db,collectionName);const snapshot=await getDocs(collectionRef);if(snapshot.empty){console.log(`ℹ️ La collection ${collectionName} est déjà vide.`);return;}// Traiter les documents par lots de 500 (limite Firestore)\nconst documents=snapshot.docs;const totalDocuments=documents.length;let processedCount=0;while(processedCount<totalDocuments){// Créer un nouveau lot pour chaque groupe de 500 documents\nconst batch=writeBatch(db);const batchSize=Math.min(500,totalDocuments-processedCount);// Ajouter les suppressions au lot\nfor(let i=0;i<batchSize;i++){const document=documents[processedCount+i];batch.delete(doc(db,collectionName,document.id));}// Exécuter le lot\nawait batch.commit();processedCount+=batchSize;console.log(`✅ Lot de ${batchSize} documents supprimés (${processedCount}/${totalDocuments})`);}console.log(`✅ Collection ${collectionName} vidée avec succès.`);}catch(error){console.error(`❌ Erreur lors de la suppression des documents:`,error);throw error;}}/**\n   * Analyse une ligne CSV en tenant compte des guillemets\n   * @param line Ligne CSV à analyser\n   * @returns Tableau des valeurs\n   */parseCSVLine(line){// Si la ligne est vide, retourner un tableau vide\nif(!line||line.trim()===''){return[];}// Supprimer TOUS les caractères \"ë\" de la ligne avant tout traitement\nlet cleanedLine=line.replace(/ë/g,'');cleanedLine=cleanedLine.replace(/Ë/g,'');// Détecter le séparateur le plus probable pour cette ligne\nlet separator=';';// On définit le point-virgule comme séparateur par défaut\nconst tabCount=(cleanedLine.match(/\\t/g)||[]).length;const semicolonCount=(cleanedLine.match(/;/g)||[]).length;const commaCount=(cleanedLine.match(/,/g)||[]).length;if(tabCount>0&&tabCount>=semicolonCount&&tabCount>=commaCount){separator='\\t';}else if(commaCount>semicolonCount){separator=',';}// Diviser la ligne en utilisant le séparateur détecté\nconst values=cleanedLine.split(separator).map(value=>{// Nettoyer chaque valeur\nlet cleanValue=value.trim();// Supprimer les guillemets en début et fin si présents\nif(cleanValue.startsWith('\"')&&cleanValue.endsWith('\"')){cleanValue=cleanValue.slice(1,-1);}// Remplacer les doubles guillemets par des simples\ncleanValue=cleanValue.replace(/\"\"/g,'\"');return cleanValue;});// Afficher des informations de débogage\nconsole.log(`Ligne nettoyée: \"${cleanedLine}\"`);console.log(`Valeurs extraites: ${JSON.stringify(values)}`);return values;}/**\n   * Normalise l'encodage des caractères spéciaux\n   * @param text Texte à normaliser\n   * @returns Texte normalisé\n   */normalizeEncoding(text){if(!text)return'';// Supprimer tous les caractères \"ë\" et \"Ë\"\nlet result=text.replace(/[ëË]/g,'');// Remplacer les caractères mal encodés par leurs équivalents corrects\nconst replacements={'Ple':'Pôle','Pole':'Pôle','POLE':'Pôle','Tourne':'Tournée','TOURNEE':'Tournée','Tournee':'Tournée','Complment':'Complément','Complement':'Complément','Tlphone':'Téléphone','Telephone':'Téléphone','Coordonnes':'Coordonnées','Coordonnees':'Coordonnées'};// Appliquer les remplacements\nObject.entries(replacements).forEach(_ref4=>{let[pattern,replacement]=_ref4;result=result.replace(new RegExp(pattern,'g'),replacement);});return result;}/**\n   * Normalise l'encodage d'un fichier CSV/TXT entier\n   * @param content Contenu du fichier\n   * @returns Contenu normalisé\n   */normalizeFileEncoding(content){if(!content)return'';console.log('Normalisation de l\\'encodage du fichier...');// Supprimer tous les caractères \"ë\"\ncontent=content.replace(/ë/g,'');// Détecter et corriger les problèmes d'encodage courants\nconst lines=content.split(/\\r?\\n/);const normalizedLines=lines.map(line=>{// Normaliser l'encodage de chaque ligne\nreturn this.normalizeEncoding(line);});return normalizedLines.join('\\n');}/**\n   * Détecte et corrige l'encodage d'un fichier CSV\n   * @param content Contenu du fichier\n   * @returns Contenu avec encodage corrigé\n   */detectAndFixEncoding(content){if(!content)return'';console.log('Détection et correction de l\\'encodage...');// Vérifier si le contenu commence par un BOM UTF-8\nif(content.charCodeAt(0)===0xFEFF){console.log('BOM UTF-8 détecté, suppression...');content=content.slice(1);}// Supprimer tous les caractères \"ë\"\nif(content.includes('ë')){console.log('Caractères \"ë\" détectés, suppression...');content=content.replace(/ë/g,'');}// Détecter les séquences typiques d'un encodage UTF-8 mal interprété\nconst hasUtf8MisinterpretedSequences=content.includes('Ã©')||// é\ncontent.includes('Ã¨')||// è\ncontent.includes('Ãª')||// ê\ncontent.includes('Ã ')||// à\ncontent.includes('Ã§')||// ç\ncontent.includes('Ã´')||// ô\ncontent.includes('Ã®')||// î\ncontent.includes('Ã¯')||// ï\ncontent.includes('Ã¼')||// ü\ncontent.includes('Ã¹')||// ù\ncontent.includes('Ã»')||// û\ncontent.includes('Ã¢')||// â\ncontent.includes('Ã«')||// ë\ncontent.includes('Ã‰')||// É\ncontent.includes('Ã\"');// Ô\nif(hasUtf8MisinterpretedSequences){console.log('Séquences UTF-8 mal interprétées détectées, correction...');// Corriger les séquences UTF-8 mal interprétées\ncontent=content.replace(/Ã©/g,'é').replace(/Ã¨/g,'è').replace(/Ãª/g,'ê').replace(/Ã /g,'à').replace(/Ã§/g,'ç').replace(/Ã´/g,'ô').replace(/Ã®/g,'î').replace(/Ã¯/g,'ï').replace(/Ã¼/g,'ü').replace(/Ã¹/g,'ù').replace(/Ã»/g,'û').replace(/Ã¢/g,'â').replace(/Ã«/g,'ë').replace(/Ã‰/g,'É').replace(/Ã\"/g,'Ô').replace(/PÃ´le/g,'Pôle').replace(/TournÃ©e/g,'Tournée').replace(/ComplÃ©ment d\\'adresse/g,'Complément d\\'adresse').replace(/TÃ©lÃ©phone/g,'Téléphone').replace(/CoordonnÃ©es/g,'Coordonnées');}// Détecter les caractères mal encodés spécifiques\nconst hasMissingAccents=content.includes('Ple')||content.includes('Tourne')||content.includes('Complment');if(hasMissingAccents){console.log('Caractères accentués manquants détectés, correction...');// Corriger les caractères mal encodés\ncontent=content.replace(/Ple/g,'Pôle').replace(/Tourne/g,'Tournée').replace(/Complment d\\'adresse/g,'Complément d\\'adresse').replace(/Complment/g,'Complément').replace(/Tlphone/g,'Téléphone').replace(/Coordonnes/g,'Coordonnées');}return content;}/**\n   * Importe des sites depuis un fichier TXT\n   * @param txtContent Contenu du fichier TXT\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */async importSitesFromTXT(txtContent){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{console.log('Traitement spécifique pour fichier TXT...');// Détecter et corriger l'encodage du fichier\nlet normalizedContent=this.detectAndFixEncoding(txtContent);// Normaliser l'encodage du contenu du fichier\nnormalizedContent=this.normalizeFileEncoding(normalizedContent);// Diviser le contenu en lignes\nconst lines=normalizedContent.split('\\n').map(line=>line.trim()).filter(line=>line!=='');if(lines.length===0){throw new Error('Le fichier est vide.');}const firstLine=lines[0];if(!firstLine){throw new Error('La première ligne du fichier est vide.');}console.log('Première ligne du fichier TXT:',firstLine);// Détecter le séparateur en comptant les occurrences\nconst tabCount=(firstLine.match(/\\t/g)||[]).length;const semicolonCount=(firstLine.match(/;/g)||[]).length;const commaCount=(firstLine.match(/,/g)||[]).length;console.log(`Séparateurs détectés - Tabulations: ${tabCount}, Points-virgules: ${semicolonCount}, Virgules: ${commaCount}`);// Afficher un échantillon des premières lignes pour le débogage\nconsole.log('Échantillon des 3 premières lignes TXT:');for(let i=0;i<Math.min(3,lines.length);i++){console.log(`Ligne ${i}: ${lines[i]}`);}// Pour les fichiers TXT, on privilégie la tabulation si elle est présente\nlet separator='\\t';if(tabCount>0){separator='\\t';console.log('Séparateur détecté pour TXT: tabulation');}else if(semicolonCount>0&&semicolonCount>=commaCount){separator=';';console.log('Séparateur détecté pour TXT: point-virgule');}else if(commaCount>0){separator=',';console.log('Séparateur détecté pour TXT: virgule');}else{console.log('Aucun séparateur standard détecté dans le fichier TXT, utilisation de la tabulation par défaut');}// Convertir le TXT en format CSV normalisé\nconst normalizedCSV=lines.map(line=>{if(!line)return'';// Remplacer le séparateur détecté par des virgules\nif(separator!==','){// Gérer correctement les champs entre guillemets avec le séparateur à l'intérieur\nconst values=this.parseCSVLine(line);return values.map(value=>{// Entourer de guillemets si la valeur contient une virgule\nif(value.includes(',')){return`\"${value.replace(/\"/g,'\"\"')}\"`;}return value;}).join(',');}return line;}).join('\\n');// Vérifier si la conversion a réussi\nconst normalizedLines=normalizedCSV.split('\\n');if(normalizedLines.length<2){throw new Error('La conversion du fichier TXT a échoué.');}// Extraire les en-têtes\nconst headers=this.parseCSVLine(normalizedLines[0]);// Vérifier que le fichier contient suffisamment de colonnes\nif(headers.length<3){throw new Error(`Le fichier ne contient que ${headers.length} colonnes. Vérifiez le format du fichier et assurez-vous qu'il utilise des tabulations, des points-virgules ou des virgules comme séparateurs.`);}console.log('En-têtes détectés dans le fichier TXT:',headers);// Traiter les lignes avec la fonction commune\nreturn this.processImportLines(headers,normalizedLines,options);}catch(error){console.error('❌ Erreur lors de l\\'importation des sites depuis TXT:',error);throw error;}}/**\n   * Affiche des informations de débogage sur un fichier CSV/TXT\n   * @param content Contenu du fichier\n   * @param fileName Nom du fichier\n   */debugFileInfo(content){let fileName=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'inconnu';console.group(`📊 Informations de débogage pour le fichier: ${fileName}`);try{// Informations générales\nconsole.log(`Taille du contenu: ${content.length} caractères`);console.log(`Type de fichier: ${fileName.endsWith('.txt')?'TXT':'CSV'}`);// Vérifier la présence du BOM UTF-8\nconst hasBOM=content.charCodeAt(0)===0xFEFF;console.log(`BOM UTF-8 détecté: ${hasBOM?'Oui':'Non'}`);// Analyser les lignes\nconst lines=content.split('\\n');console.log(`Nombre de lignes: ${lines.length}`);if(lines.length>0){// Analyser la première ligne (en-têtes)\nconst firstLine=lines[0].trim();console.log(`Première ligne (${firstLine.length} caractères): ${firstLine.substring(0,100)}${firstLine.length>100?'...':''}`);// Détecter les séparateurs\nconst tabCount=(firstLine.match(/\\t/g)||[]).length;const semicolonCount=(firstLine.match(/;/g)||[]).length;const commaCount=(firstLine.match(/,/g)||[]).length;console.log(`Séparateurs détectés - Tabulations: ${tabCount}, Points-virgules: ${semicolonCount}, Virgules: ${commaCount}`);// Détecter le séparateur le plus probable\nlet probableSeparator=',';if(tabCount>0&&tabCount>=semicolonCount&&tabCount>=commaCount){probableSeparator='\\t';}else if(semicolonCount>0&&semicolonCount>=commaCount){probableSeparator=';';}console.log(`Séparateur le plus probable: ${probableSeparator==='\\t'?'tabulation':probableSeparator}`);// Estimer le nombre de colonnes\nconst estimatedColumns=probableSeparator==='\\t'?tabCount+1:probableSeparator===';'?semicolonCount+1:commaCount+1;console.log(`Nombre estimé de colonnes: ${estimatedColumns}`);// Vérifier la cohérence des lignes\nif(lines.length>1){const secondLine=lines[1].trim();const secondLineTabCount=(secondLine.match(/\\t/g)||[]).length;const secondLineSemicolonCount=(secondLine.match(/;/g)||[]).length;const secondLineCommaCount=(secondLine.match(/,/g)||[]).length;const secondLineColumns=probableSeparator==='\\t'?secondLineTabCount+1:probableSeparator===';'?secondLineSemicolonCount+1:secondLineCommaCount+1;console.log(`Nombre de colonnes dans la deuxième ligne: ${secondLineColumns}`);console.log(`Cohérence des colonnes: ${estimatedColumns===secondLineColumns?'OK':'PROBLÈME'}`);}// Vérifier l'encodage des caractères spéciaux\nconst specialChars=['é','è','ê','à','ç','ô','î','ï','ü','ù','û','â','ë'];const specialCharsFound=specialChars.filter(char=>content.includes(char));console.log(`Caractères spéciaux correctement encodés: ${specialCharsFound.length>0?specialCharsFound.join(', '):'Aucun'}`);// Vérifier les séquences UTF-8 mal interprétées\nconst badSequences=['Ã©','Ã¨','Ãª','Ã ','Ã§','Ã´','Ã®','Ã¯','Ã¼','Ã¹','Ã»','Ã¢','Ã«'];const badSequencesFound=badSequences.filter(seq=>content.includes(seq));console.log(`Séquences UTF-8 mal interprétées: ${badSequencesFound.length>0?badSequencesFound.join(', '):'Aucune'}`);// Vérifier les caractères mal encodés spécifiques\nconst specificBadChars=['Ple','Tourne','Complment'];const specificBadCharsFound=specificBadChars.filter(char=>content.includes(char));console.log(`Caractères mal encodés spécifiques: ${specificBadCharsFound.length>0?specificBadCharsFound.join(', '):'Aucun'}`);}}catch(error){console.error('Erreur lors de l\\'analyse du fichier:',error);}finally{console.groupEnd();}}/**\n   * Importe des sites depuis un fichier CSV\n   * @param csvContent Contenu du fichier CSV\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */async importSitesFromCSV(csvContent){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{const{clearCollection=false,updateExisting=true,idField='id',isTxtFile=false,fileName=isTxtFile?'fichier.txt':'fichier.csv'}=options;console.log(`Début de l'importation des sites depuis ${isTxtFile?'TXT':'CSV'}...`);// Afficher des informations de débogage sur le fichier\nthis.debugFileInfo(csvContent,fileName);// Traitement spécifique pour les fichiers TXT\nif(isTxtFile){return this.importSitesFromTXT(csvContent,options);}// Supprimer tous les caractères \"ë\" du contenu\nlet cleanedContent=csvContent.replace(/ë/g,'');console.log('Contenu après nettoyage des caractères ë (50 premiers caractères):',cleanedContent.substring(0,50));// Détecter et corriger l'encodage du fichier\nlet normalizedContent=this.detectAndFixEncoding(cleanedContent);// Vérifier si le contenu est encodé en UTF-8 avec BOM\nif(csvContent.charCodeAt(0)===0xFEFF){console.log('Détection du BOM UTF-8, suppression...');normalizedContent=csvContent.slice(1);}// Normaliser l'encodage du contenu du fichier\nnormalizedContent=this.normalizeFileEncoding(normalizedContent);// Diviser le contenu en lignes\nconst lines=normalizedContent.split(/\\r?\\n/).map(line=>line.trim()).filter(line=>line!=='');if(lines.length===0){throw new Error('Le fichier est vide.');}const firstLine=lines[0];if(!firstLine){throw new Error('La première ligne du fichier est vide.');}console.log('Première ligne du fichier:',firstLine);// Détecter le séparateur en comptant les occurrences\nconst tabCount=(firstLine.match(/\\t/g)||[]).length;const semicolonCount=(firstLine.match(/;/g)||[]).length;const commaCount=(firstLine.match(/,/g)||[]).length;// Initialiser la variable separator\nlet separator=',';// Détecter si c'est le format spécifique de l'utilisateur\nconst isUserSpecificFormat=firstLine.includes('Pôle;Bassin;MI;Tournée')||firstLine.includes('Pôle;Bassin;MI;Tournée;PT de rattachement')||firstLine.includes('Pole;Bassin;MI;Tournee')||firstLine.includes('ID;Pole;Bassin;MI;Tournee');if(isUserSpecificFormat){console.log('Format spécifique détecté: format utilisateur avec séparateur point-virgule');separator=';';}console.log(`Séparateurs détectés - Tabulations: ${tabCount}, Points-virgules: ${semicolonCount}, Virgules: ${commaCount}`);console.log(`Format détecté: ${isUserSpecificFormat?'Format utilisateur spécifique':'Format standard'}`);// Pour les fichiers TXT, on privilégie la tabulation si elle est présente\nif(isTxtFile){if(tabCount>0){separator='\\t';console.log('Séparateur détecté pour TXT: tabulation');}else if(semicolonCount>0&&semicolonCount>=commaCount){separator=';';console.log('Séparateur détecté pour TXT: point-virgule');}else if(commaCount>0){separator=',';console.log('Séparateur détecté pour TXT: virgule');}else{console.log('Aucun séparateur standard détecté dans le fichier TXT, utilisation de la tabulation par défaut');}}else{// Pour les fichiers CSV, logique existante\nif(tabCount>0&&tabCount>=semicolonCount&&tabCount>=commaCount){separator='\\t';console.log('Séparateur détecté pour CSV: tabulation');}else if(semicolonCount>0&&semicolonCount>=commaCount){separator=';';console.log('Séparateur détecté pour CSV: point-virgule');}else{console.log('Séparateur détecté pour CSV: virgule');}}// Afficher un échantillon des premières lignes pour le débogage\nconsole.log('Échantillon des 3 premières lignes:');for(let i=0;i<Math.min(3,lines.length);i++){console.log(`Ligne ${i}: ${lines[i]}`);}// Convertir le CSV en utilisant le séparateur détecté\nlet normalizedCSV='';if(separator!==','){normalizedCSV=lines.map(line=>{if(!line)return'';// Gérer correctement les champs entre guillemets avec le séparateur à l'intérieur\nconst result=[];let current='';let inQuotes=false;for(let i=0;i<line.length;i++){const char=line[i];if(char==='\"'){inQuotes=!inQuotes;current+=char;}else if(char===separator&&!inQuotes){result.push(current);current='';}else{current+=char;}}// Ajouter le dernier champ\nresult.push(current);return result.join(',');}).join('\\n');}else{normalizedCSV=normalizedContent;}// Vérifier si le fichier a été correctement normalisé\nconst normalizedLines=normalizedCSV.split(/\\r?\\n/).filter(line=>line.trim()!=='');if(normalizedLines.length<2){// Si la normalisation a échoué, essayer une approche différente\nconsole.warn('⚠️ La normalisation standard a échoué, tentative avec une approche alternative...');// Utiliser directement les lignes d'origine et laisser parseCSVLine gérer les séparateurs\nconst alternativeLines=lines.filter(line=>line.trim()!=='');if(alternativeLines.length<2){throw new Error('Le fichier est vide ou ne contient que des en-têtes.');}// Extraire les en-têtes avec la fonction parseCSVLine améliorée\nconst headers=this.parseCSVLine(alternativeLines[0]);// Vérifier que le fichier contient suffisamment de colonnes\nif(headers.length<3){throw new Error(`Le fichier ne contient que ${headers.length} colonnes. Vérifiez le format du fichier et assurez-vous qu'il utilise des virgules, des points-virgules ou des tabulations comme séparateurs.`);}console.log('En-têtes détectés (approche alternative):',headers);// Continuer avec les lignes alternatives\nreturn this.processImportLines(headers,alternativeLines,options);}// Extraire les en-têtes\nconst headers=this.parseCSVLine(normalizedLines[0]);// Vérifier que le CSV contient suffisamment de colonnes\nif(headers.length<3){throw new Error(`Le fichier ne contient que ${headers.length} colonnes. Vérifiez le format du fichier et assurez-vous qu'il utilise des virgules, des points-virgules ou des tabulations comme séparateurs.`);}console.log('En-têtes détectés:',headers);return this.processImportLines(headers,normalizedLines,options);}catch(error){console.error(`❌ Erreur lors de l'importation des sites depuis ${isTxtFile?'TXT':'CSV'}:`,error);throw error;}}/**\n   * Traite les lignes importées pour extraire les documents\n   * @param headers En-têtes des colonnes\n   * @param lines Lignes de données\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */async processImportLines(headers,lines){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};try{const{clearCollection=false,updateExisting=true,idField='id'}=options;// Récupérer tous les sites existants pour la vérification des doublons\nconst sitesRef=collection(db,'sites');const existingSites=await getDocs(sitesRef);const existingSitesMap=new Map();const existingSitesByName=new Map();const existingSitesByAddress=new Map();existingSites.forEach(doc=>{const siteData=doc.data();existingSitesMap.set(doc.id,siteData);// Index par nom normalisé\nif(siteData.nom){const normalizedName=siteData.nom.toLowerCase().trim();existingSitesByName.set(normalizedName,{id:doc.id,...siteData});}// Index par adresse complète normalisée\nif(siteData.adresse&&siteData.ville&&siteData.codePostal){const normalizedAddress=`${siteData.adresse},${siteData.ville},${siteData.codePostal}`.toLowerCase().replace(/\\s+/g,'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'');existingSitesByAddress.set(normalizedAddress,{id:doc.id,...siteData});}});// Nettoyer les en-têtes avant de les normaliser\nconst cleanedHeaders=headers.map(header=>header.replace(/ë/g,''));const normalizedHeaders=this.normalizeHeaders(cleanedHeaders);let importCount=0;let skipCount=0;let updateCount=0;// Traiter les lignes par lots de 500\nconst BATCH_SIZE=500;const totalLines=lines.length-1;// Exclure l'en-tête\nfor(let startIndex=1;startIndex<lines.length;startIndex+=BATCH_SIZE){// Créer un nouveau batch pour chaque groupe\nconst batch=writeBatch(db);let batchCount=0;const endIndex=Math.min(startIndex+BATCH_SIZE,lines.length);for(let i=startIndex;i<endIndex;i++){const line=lines[i];if(!line.trim())continue;const values=this.parseCSVLine(line);const document={};// Construire le document à partir des valeurs\nnormalizedHeaders.forEach((header,index)=>{if(header&&values[index]){document[header]=this.normalizeValue(values[index].trim(),header);}});// Vérifier si le site existe déjà\nlet existingSite=null;// 1. Vérifier par ID si disponible\nif(document.id){existingSite=existingSitesMap.get(document.id);}// 2. Vérifier par nom normalisé\nif(!existingSite&&document.nom){const normalizedName=document.nom.toLowerCase().trim();existingSite=existingSitesByName.get(normalizedName);}// 3. Vérifier par adresse complète\nif(!existingSite&&document.adresse&&document.ville&&document.codePostal){const normalizedAddress=`${document.adresse},${document.ville},${document.codePostal}`.toLowerCase().replace(/\\s+/g,'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'');existingSite=existingSitesByAddress.get(normalizedAddress);}// Si le site existe déjà\nif(existingSite){if(!updateExisting){skipCount++;continue;}// Vérifier si les données sont différentes avant de mettre à jour\nconst hasChanges=Object.keys(document).some(key=>document[key]!==existingSite[key]&&document[key]!==undefined);if(!hasChanges){skipCount++;continue;}// Mettre à jour le site existant\nconst siteRef=doc(db,'sites',existingSite.id);batch.set(siteRef,document);updateCount++;batchCount++;}else{// Créer un nouveau site\nconst newSiteRef=doc(collection(db,'sites'));batch.set(newSiteRef,document);importCount++;batchCount++;}}// Commiter le batch s'il contient des opérations\nif(batchCount>0){await batch.commit();console.log(`Lot de ${batchCount} documents traité (${startIndex}/${totalLines})`);}}console.log(`\n        Importation terminée:\n        - ${importCount} nouveaux sites importés\n        - ${updateCount} sites mis à jour\n        - ${skipCount} sites ignorés (doublons ou sans changements)\n      `);return importCount+updateCount;}catch(error){console.error('Erreur lors du traitement des lignes:',error);throw error;}}/**\n   * Normalise les en-têtes pour corriger les problèmes d'encodage\n   * @param headers Tableau des en-têtes\n   * @returns Tableau des en-têtes normalisés\n   */normalizeHeaders(headers){console.log('Normalisation des en-têtes...');console.log('En-têtes originaux:',headers);// Mapping complet des en-têtes\nconst headerReplacements={// Variations de Pôle\n'pole':'pole','pôle':'pole','pôles':'pole','poles':'pole','ple':'pole','p le':'pole','p.le':'pole','p?le':'pole',// Variations de Type\n'type':'type','type de site':'type','type site':'type','categorie':'type','catégorie':'type',// Variations de Nom\n'nom':'nom','nom site':'nom','site':'nom','nom du site':'nom','denomination':'nom','dénomination':'nom',// Variations d'Adresse\n'adresse':'adresse','adresses':'adresse','adr':'adresse','adresse site':'adresse','adresse complete':'adresse','adresse complète':'adresse',// Variations de Complément d'adresse\n'complement':'complementAdresse','complément':'complementAdresse','complement adresse':'complementAdresse','complément adresse':'complementAdresse','complement d\\'adresse':'complementAdresse','complément d\\'adresse':'complementAdresse',// Variations de Ville\n'ville':'ville','commune':'ville','localite':'ville','localité':'ville','villes':'ville',// Variations de Code postal\n'cp':'codePostal','code postal':'codePostal','code_postal':'codePostal','codepostal':'codePostal','cp site':'codePostal',// Variations de Pays\n'pays':'pays','country':'pays','nation':'pays',// Variations de Téléphone\n'tel':'telephone','tél':'telephone','telephone':'telephone','téléphone':'telephone','num tel':'telephone','numéro':'telephone',// Variations d'Email\n'email':'email','e-mail':'email','mail':'email','courriel':'email','adresse mail':'email',// Variations de Status\n'status':'statut','statut':'statut','etat':'statut','état':'statut',// Variations de Tournée\n'tournee':'tournees','tournée':'tournees','tournees':'tournees','tournées':'tournees',// Variations de MI\n'mi':'mi','responsable':'mi','responsable mi':'mi',// Variations de Bassin\n'bassin':'bassin','zone':'bassin','secteur':'bassin',// Autres champs\n'id':'id','identifiant':'id','reference':'id','référence':'id','horaires lv':'horairesLV','horaire lv':'horairesLV','horaires semaine':'horairesLV','horaires sam':'horairesSamedi','horaire sam':'horairesSamedi','horaires samedi':'horairesSamedi'};// Nettoyer et normaliser les en-têtes\nconst normalizedHeaders=headers.map(header=>{// Nettoyage initial\nconst cleanHeader=header.trim().toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g,'')// Supprimer les accents\n.replace(/[^a-z0-9\\s]/g,' ')// Garder uniquement les lettres, chiffres et espaces\n.replace(/\\s+/g,' ')// Normaliser les espaces\n.trim();// Rechercher dans le mapping\nconst mappedHeader=headerReplacements[cleanHeader];if(mappedHeader){console.log(`En-tête normalisé: \"${header}\" -> \"${mappedHeader}\"`);return mappedHeader;}// Si pas trouvé dans le mapping, retourner la version nettoyée\nconsole.log(`En-tête non mappé: \"${header}\" -> \"${cleanHeader}\"`);return cleanHeader;});console.log('En-têtes finaux après normalisation:',normalizedHeaders);return normalizedHeaders;}/**\n   * Normalise les valeurs des colonnes\n   * @param value Valeur à normaliser\n   * @param fieldName Nom du champ\n   * @returns Valeur normalisée\n   */normalizeValue(value,fieldName){if(!value)return'';// Supprimer les caractères spéciaux et les espaces en trop\nlet normalizedValue=value.trim().replace(/[ëË]/g,'').replace(/\\s+/g,' ');// Normalisation spécifique selon le type de champ\nswitch(fieldName.toLowerCase()){case'pole':// Normaliser les variations de \"Pôle\"\nnormalizedValue=normalizedValue.replace(/^p[oôó]le\\s*/i,'').replace(/^p\\s*[oôó]le\\s*/i,'').trim();break;case'type':// Normaliser les types de sites\nconst lowerValue=normalizedValue.toLowerCase();if(lowerValue.includes('labo')||lowerValue.includes('lab')){normalizedValue='Laboratoire';}else if(lowerValue.includes('site')){normalizedValue='Site';}else if(lowerValue.includes('client')){normalizedValue='Client';}else if(lowerValue.includes('point')){normalizedValue='Point de collecte';}else{normalizedValue=normalizedValue.charAt(0).toUpperCase()+normalizedValue.slice(1).toLowerCase();}break;case'ville':case'nom':// Capitaliser chaque mot pour les villes et les noms\nnormalizedValue=normalizedValue.split(' ').map(word=>word.charAt(0).toUpperCase()+word.slice(1).toLowerCase()).join(' ');break;case'codepostal':// Nettoyer le code postal (garder uniquement les chiffres)\nnormalizedValue=normalizedValue.replace(/\\D/g,'');break;case'telephone':// Normaliser les numéros de téléphone\nnormalizedValue=normalizedValue.replace(/\\D/g,'');if(normalizedValue.length===10){normalizedValue=normalizedValue.replace(/(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/,'$1.$2.$3.$4.$5');}break;case'email':// Mettre les emails en minuscules\nnormalizedValue=normalizedValue.toLowerCase();break;case'adresse':// Normaliser les adresses\nnormalizedValue=normalizedValue.replace(/\\s+/g,' ').replace(/,\\s*/g,', ').replace(/\\s*-\\s*/g,'-').trim();break;}return normalizedValue;}/**\n   * Traite spécifiquement le format de données fourni par l'utilisateur\n   * @param csvContent Contenu du fichier CSV\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */async importUserSpecificFormat(csvContent){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{console.log('🔄 Importation avec le format spécifique de l\\'utilisateur...');// Options par défaut\nconst{clearCollection=false,updateExisting=true,idField='id'}=options;// Séparer les lignes\nconst lines=csvContent.split('\\n').filter(line=>line.trim()!=='');if(lines.length<2){throw new Error('Le fichier est vide ou ne contient que des en-têtes.');}// Extraire et normaliser les en-têtes\nconst headers=lines[0].split(';').map(header=>header.trim());const normalizedHeaders=this.normalizeHeaders(headers);console.log('En-têtes normalisés:',normalizedHeaders);// Mapper les en-têtes aux champs de la base de données\nconst fieldMap={'pole':'pole','pôle':'pole','tournée':'tournees','type de site':'type','nom':'nom','adresse':'adresse','complément d\\'adresse':'complementAdresse','ville':'ville','code postal':'codePostal','pays':'pays','horaire d\\'ouverture - lundi - vendredi':'horairesLV','horaire d\\'ouverture - samedi -':'horairesSamedi','id':'id'};// Créer un mapping des indices de colonnes vers les noms de champs\nconst columnMap={};normalizedHeaders.forEach((header,index)=>{const mappedField=fieldMap[header.toLowerCase()];if(mappedField){columnMap[index]=mappedField;console.log(`Mapped header \"${header}\" to field \"${mappedField}\"`);}else{console.log(`No mapping found for header \"${header}\"`);}});// Préparer les documents\nconst documents=[];// Traiter chaque ligne (sauf la première qui contient les en-têtes)\nfor(let i=1;i<lines.length;i++){const line=lines[i].trim();if(!line)continue;// Diviser la ligne en valeurs\nconst values=line.split(';');// Créer un document avec les valeurs par défaut\nconst doc={pole:'',nom:'',type:'Laboratoire',adresse:'',ville:'',codePostal:'',telephone:'',email:'',codeBarres:'',tournees:[],codesPorte:'',coordonnees:'',statut:'actif',complementAdresse:'',pays:'France',horairesLV:'',horairesSamedi:''};// Remplir le document avec les valeurs de la ligne\nlet hasValidName=false;for(let j=0;j<values.length;j++){const fieldName=columnMap[j];if(!fieldName)continue;let value=values[j].trim();// Traitement spécial pour certains champs\nif(fieldName==='tournees'&&value){// Convertir en tableau\nvalue=[value];}else if(fieldName==='type'&&value){// Standardiser le type\nconst lowerValue=value.toLowerCase();if(lowerValue.includes('labo')||lowerValue.includes('lab')){value='Laboratoire';}else if(lowerValue.includes('site')){value='Site';}else if(lowerValue.includes('client')){value='Client';}else if(lowerValue.includes('point')){value='Point de collecte';}else{value=value.charAt(0).toUpperCase()+value.slice(1).toLowerCase();}}// Assigner la valeur au document\nif(value!==''){doc[fieldName]=value;// Vérifier si nous avons un nom valide\nif(fieldName==='nom'&&value){hasValidName=true;}}}// Si nous n'avons pas de nom mais avons une adresse, utiliser l'adresse comme nom\nif(!hasValidName&&!doc.nom&&doc.adresse){doc.nom=`Site - ${doc.adresse}`;hasValidName=true;}// Ajouter le document s'il a un nom ou un ID\nif(hasValidName||doc.id){documents.push(doc);}else{console.warn(`⚠️ Ligne ${i+1} ignorée: aucun nom ou identifiant valide trouvé`);}}if(documents.length===0){throw new Error('Aucun document valide n\\'a pu être extrait du fichier.');}console.log(`✅ ${documents.length} sites valides extraits du fichier`);// Vider la collection si demandé\nif(clearCollection){await this.clearCollection('sites');}// Importer les documents\nconst totalDocuments=documents.length;let processedCount=0;let importedCount=0;while(processedCount<totalDocuments){// Créer un nouveau lot pour chaque groupe de 500 documents\nconst batch=writeBatch(db);const batchSize=Math.min(500,totalDocuments-processedCount);// Ajouter les documents au lot\nfor(let i=0;i<batchSize;i++){const document=documents[processedCount+i];const docId=document[idField];if(docId&&updateExisting){// Mettre à jour ou créer le document avec l'ID spécifié\nconst docRef=doc(db,'sites',docId);batch.set(docRef,document);}else{// Créer un nouveau document avec un ID généré\nconst collectionRef=collection(db,'sites');const newDocRef=doc(collectionRef);batch.set(newDocRef,document);}importedCount++;}// Exécuter le lot\nawait batch.commit();processedCount+=batchSize;console.log(`✅ Lot de ${batchSize} sites importés (${processedCount}/${totalDocuments})`);}console.log(`✅ Importation terminée: ${importedCount} sites importés`);return importedCount;}catch(error){console.error('❌ Erreur lors de l\\'importation avec le format spécifique:',error);throw error;}}}export default new SharePointService();","map":{"version":3,"names":["db","collection","getDocs","Timestamp","doc","writeBatch","JSZip","SharePointService","constructor","collections","exportCollectionToCSV","collectionName","console","log","querySnapshot","empty","documents","docs","map","data","formattedData","Object","entries","forEach","_ref","key","value","toDate","toISOString","id","allKeys","Set","keys","add","headers","Array","from","csv","join","row","header","undefined","includes","replace","length","error","exportCollectionToJSON","_ref2","downloadCollectionAsCSV","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","setAttribute","Date","split","style","visibility","body","appendChild","click","removeChild","downloadCollectionAsJSON","JSON","stringify","downloadAllCollectionsAsCSV","downloadAllCollectionsAsJSON","generateCompleteBackup","zip","file","content","generateAsync","importCSVToCollection","csvContent","options","arguments","clearCollection","updateExisting","idField","Error","lines","parseCSVLine","i","line","trim","values","warn","j","isNaN","Number","match","fromDate","e","push","totalDocuments","processedCount","importedCount","batch","batchSize","Math","min","docId","docRef","set","collectionRef","newDocRef","commit","importJSONToCollection","jsonData","isArray","processedDoc","_ref3","importFromZip","zipContent","loadAsync","results","fileName","files","_fileName$split$pop","dir","fileExt","pop","toLowerCase","fileContent","async","parse","count","snapshot","delete","cleanedLine","separator","tabCount","semicolonCount","commaCount","cleanValue","startsWith","endsWith","slice","normalizeEncoding","text","result","replacements","_ref4","pattern","replacement","RegExp","normalizeFileEncoding","normalizedLines","detectAndFixEncoding","charCodeAt","hasUtf8MisinterpretedSequences","hasMissingAccents","importSitesFromTXT","txtContent","normalizedContent","filter","firstLine","normalizedCSV","processImportLines","debugFileInfo","group","hasBOM","substring","probableSeparator","estimatedColumns","secondLine","secondLineTabCount","secondLineSemicolonCount","secondLineCommaCount","secondLineColumns","specialChars","specialCharsFound","char","badSequences","badSequencesFound","seq","specificBadChars","specificBadCharsFound","groupEnd","importSitesFromCSV","isTxtFile","cleanedContent","isUserSpecificFormat","current","inQuotes","alternativeLines","sitesRef","existingSites","existingSitesMap","Map","existingSitesByName","existingSitesByAddress","siteData","nom","normalizedName","adresse","ville","codePostal","normalizedAddress","normalize","cleanedHeaders","normalizedHeaders","normalizeHeaders","importCount","skipCount","updateCount","BATCH_SIZE","totalLines","startIndex","batchCount","endIndex","index","normalizeValue","existingSite","get","hasChanges","some","siteRef","newSiteRef","headerReplacements","cleanHeader","mappedHeader","fieldName","normalizedValue","lowerValue","charAt","toUpperCase","word","importUserSpecificFormat","fieldMap","columnMap","mappedField","pole","telephone","email","codeBarres","tournees","codesPorte","coordonnees","statut","complementAdresse","pays","horairesLV","horairesSamedi","hasValidName"],"sources":["C:/Users/LS_110/Documents/GitHub/inovie-SCAN-web-main/src/services/SharePointService.ts"],"sourcesContent":["import { db } from '../config/firebase';\nimport { collection, getDocs, query, where, orderBy, limit, Timestamp, addDoc, doc, setDoc, deleteDoc, writeBatch } from 'firebase/firestore';\nimport JSZip from 'jszip';\n\n/**\n * Service pour gérer l'intégration entre Firebase et SharePoint\n * Utilise une approche de synchronisation manuelle via fichiers CSV/JSON\n * pour contourner les limitations de double authentification\n */\nexport class SharePointService {\n  // Collections Firebase à synchroniser\n  private collections = ['passages', 'sites', 'tournees', 'vehicules'];\n  \n  /**\n   * Exporte les données d'une collection Firebase au format CSV\n   * @param collectionName Nom de la collection à exporter\n   * @returns Chaîne de caractères au format CSV\n   */\n  async exportCollectionToCSV(collectionName: string): Promise<string> {\n    try {\n      console.log(`🔄 Exportation de la collection ${collectionName} au format CSV...`);\n      \n      // Récupérer les données de la collection\n      const querySnapshot = await getDocs(collection(db, collectionName));\n      \n      if (querySnapshot.empty) {\n        console.log(`⚠️ La collection ${collectionName} est vide.`);\n        return '';\n      }\n      \n      // Extraire les données\n      const documents = querySnapshot.docs.map(doc => {\n        const data = doc.data();\n        \n        // Convertir les Timestamp en chaînes de caractères\n        const formattedData: Record<string, any> = {};\n        \n        Object.entries(data).forEach(([key, value]) => {\n          if (value instanceof Timestamp) {\n            formattedData[key] = value.toDate().toISOString();\n          } else {\n            formattedData[key] = value;\n          }\n        });\n        \n        // Ajouter l'ID du document\n        formattedData.id = doc.id;\n        \n        return formattedData;\n      });\n      \n      // Obtenir toutes les clés uniques pour les en-têtes CSV\n      const allKeys = new Set<string>();\n      documents.forEach(doc => {\n        Object.keys(doc).forEach(key => allKeys.add(key));\n      });\n      \n      const headers = Array.from(allKeys);\n      \n      // Générer le CSV\n      let csv = headers.join(',') + '\\n';\n      \n      documents.forEach(doc => {\n        const row = headers.map(header => {\n          const value = doc[header];\n          \n          // Échapper les valeurs contenant des virgules ou des sauts de ligne\n          if (value === undefined || value === null) {\n            return '';\n          } else if (typeof value === 'string' && (value.includes(',') || value.includes('\\n') || value.includes('\"'))) {\n            return `\"${value.replace(/\"/g, '\"\"')}\"`;\n          } else {\n            return value;\n          }\n        });\n        \n        csv += row.join(',') + '\\n';\n      });\n      \n      console.log(`✅ Exportation de ${documents.length} documents de la collection ${collectionName} terminée.`);\n      \n      return csv;\n    } catch (error) {\n      console.error(`❌ Erreur lors de l'exportation de la collection ${collectionName}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Exporte les données d'une collection Firebase au format JSON\n   * @param collectionName Nom de la collection à exporter\n   * @returns Objet JSON contenant les données\n   */\n  async exportCollectionToJSON(collectionName: string): Promise<any[]> {\n    try {\n      console.log(`🔄 Exportation de la collection ${collectionName} au format JSON...`);\n      \n      // Récupérer les données de la collection\n      const querySnapshot = await getDocs(collection(db, collectionName));\n      \n      if (querySnapshot.empty) {\n        console.log(`⚠️ La collection ${collectionName} est vide.`);\n        return [];\n      }\n      \n      // Extraire les données\n      const documents = querySnapshot.docs.map(doc => {\n        const data = doc.data();\n        \n        // Convertir les Timestamp en chaînes de caractères\n        const formattedData: Record<string, any> = {};\n        \n        Object.entries(data).forEach(([key, value]) => {\n          if (value instanceof Timestamp) {\n            formattedData[key] = value.toDate().toISOString();\n          } else {\n            formattedData[key] = value;\n          }\n        });\n        \n        // Ajouter l'ID du document\n        formattedData.id = doc.id;\n        \n        return formattedData;\n      });\n      \n      console.log(`✅ Exportation de ${documents.length} documents de la collection ${collectionName} terminée.`);\n      \n      return documents;\n    } catch (error) {\n      console.error(`❌ Erreur lors de l'exportation de la collection ${collectionName}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Télécharge un fichier CSV contenant les données d'une collection\n   * @param collectionName Nom de la collection à exporter\n   */\n  async downloadCollectionAsCSV(collectionName: string): Promise<void> {\n    try {\n      const csv = await this.exportCollectionToCSV(collectionName);\n      \n      if (!csv) {\n        console.log(`⚠️ Aucune donnée à exporter pour la collection ${collectionName}.`);\n        return;\n      }\n      \n      // Créer un blob et un lien de téléchargement\n      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      \n      link.setAttribute('href', url);\n      link.setAttribute('download', `${collectionName}_${new Date().toISOString().split('T')[0]}.csv`);\n      link.style.visibility = 'hidden';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    } catch (error) {\n      console.error(`❌ Erreur lors du téléchargement de la collection ${collectionName}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Télécharge un fichier JSON contenant les données d'une collection\n   * @param collectionName Nom de la collection à exporter\n   */\n  async downloadCollectionAsJSON(collectionName: string): Promise<void> {\n    try {\n      const data = await this.exportCollectionToJSON(collectionName);\n      \n      if (!data || data.length === 0) {\n        console.log(`⚠️ Aucune donnée à exporter pour la collection ${collectionName}.`);\n        return;\n      }\n      \n      // Créer un blob et un lien de téléchargement\n      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      \n      link.setAttribute('href', url);\n      link.setAttribute('download', `${collectionName}_${new Date().toISOString().split('T')[0]}.json`);\n      link.style.visibility = 'hidden';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    } catch (error) {\n      console.error(`❌ Erreur lors du téléchargement de la collection ${collectionName}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Télécharge toutes les collections au format CSV\n   */\n  async downloadAllCollectionsAsCSV(): Promise<void> {\n    try {\n      console.log('🔄 Exportation de toutes les collections au format CSV...');\n      \n      for (const collectionName of this.collections) {\n        await this.downloadCollectionAsCSV(collectionName);\n      }\n      \n      console.log('✅ Exportation de toutes les collections terminée.');\n    } catch (error) {\n      console.error('❌ Erreur lors de l\\'exportation de toutes les collections:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Télécharge toutes les collections au format JSON\n   */\n  async downloadAllCollectionsAsJSON(): Promise<void> {\n    try {\n      console.log('🔄 Exportation de toutes les collections au format JSON...');\n      \n      for (const collectionName of this.collections) {\n        await this.downloadCollectionAsJSON(collectionName);\n      }\n      \n      console.log('✅ Exportation de toutes les collections terminée.');\n    } catch (error) {\n      console.error('❌ Erreur lors de l\\'exportation de toutes les collections:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Génère un fichier ZIP contenant toutes les collections au format JSON\n   */\n  async generateCompleteBackup(): Promise<void> {\n    try {\n      console.log(\"🔄 Génération d'une sauvegarde complète...\");\n      \n      const zip = new JSZip();\n      \n      // Exporter chaque collection\n      for (const collectionName of this.collections) {\n        const data = await this.exportCollectionToJSON(collectionName);\n        \n        if (data && data.length > 0) {\n          zip.file(`${collectionName}.json`, JSON.stringify(data, null, 2));\n        }\n      }\n      \n      // Générer le fichier ZIP\n      const content = await zip.generateAsync({ type: 'blob' });\n      \n      // Télécharger le fichier\n      const url = URL.createObjectURL(content);\n      const link = document.createElement('a');\n      \n      link.setAttribute('href', url);\n      link.setAttribute('download', `firebase_backup_${new Date().toISOString().split('T')[0]}.zip`);\n      link.style.visibility = 'hidden';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      console.log('✅ Génération de la sauvegarde complète terminée.');\n    } catch (error) {\n      console.error('❌ Erreur lors de la génération de la sauvegarde complète:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Importe des données au format CSV vers une collection Firebase\n   * @param collectionName Nom de la collection cible\n   * @param csvContent Contenu du fichier CSV\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */\n  async importCSVToCollection(\n    collectionName: string, \n    csvContent: string,\n    options: {\n      clearCollection?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n    } = {}\n  ): Promise<number> {\n    try {\n      console.log(`🔄 Importation des données CSV vers la collection ${collectionName}...`);\n      \n      // Options par défaut\n      const { \n        clearCollection = false, \n        updateExisting = true,\n        idField = 'id'\n      } = options;\n      \n      // Vérifier si la collection existe\n      if (!this.collections.includes(collectionName)) {\n        throw new Error(`La collection ${collectionName} n'est pas valide.`);\n      }\n      \n      // Analyser le CSV\n      const lines = csvContent.split('\\n');\n      if (lines.length < 2) {\n        throw new Error('Le fichier CSV est vide ou ne contient que des en-têtes.');\n      }\n      \n      // Extraire les en-têtes\n      const headers = this.parseCSVLine(lines[0]);\n      \n      // Préparer les données\n      const documents: Record<string, any>[] = [];\n      \n      for (let i = 1; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        \n        const values = this.parseCSVLine(line);\n        if (values.length !== headers.length) {\n          console.warn(`⚠️ Ligne ${i + 1} ignorée: nombre de valeurs incorrect`);\n          continue;\n        }\n        \n        const doc: Record<string, any> = {};\n        \n        for (let j = 0; j < headers.length; j++) {\n          const header = headers[j];\n          let value: any = values[j];\n          \n          // Convertir les valeurs en types appropriés\n          if (value === 'true') value = true;\n          else if (value === 'false') value = false;\n          else if (!isNaN(Number(value)) && value !== '') value = Number(value);\n          else if (typeof value === 'string' && (value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/) || value.match(/^\\d{4}-\\d{2}-\\d{2}/))) {\n            // Convertir les dates ISO en Timestamp\n            try {\n              value = Timestamp.fromDate(new Date(value));\n            } catch (e) {\n              console.warn(`⚠️ Impossible de convertir la date: ${value}`);\n            }\n          }\n          \n          doc[header] = value;\n        }\n        \n        documents.push(doc);\n      }\n      \n      // Vider la collection si demandé\n      if (clearCollection) {\n        await this.clearCollection(collectionName);\n      }\n      \n      // Importer les documents\n      const totalDocuments = documents.length;\n      let processedCount = 0;\n      let importedCount = 0;\n      \n      while (processedCount < totalDocuments) {\n        // Créer un nouveau lot pour chaque groupe de 500 documents\n        const batch = writeBatch(db);\n        const batchSize = Math.min(500, totalDocuments - processedCount);\n        \n        // Ajouter les documents au lot\n        for (let i = 0; i < batchSize; i++) {\n          const document = documents[processedCount + i];\n          const docId = document[idField];\n          \n          if (docId && updateExisting) {\n            // Mettre à jour ou créer le document avec l'ID spécifié\n            const docRef = doc(db, collectionName, docId);\n            batch.set(docRef, document);\n          } else {\n            // Créer un nouveau document avec un ID généré\n            const collectionRef = collection(db, collectionName);\n            const newDocRef = doc(collectionRef);\n            batch.set(newDocRef, document);\n          }\n          \n          importedCount++;\n        }\n        \n        // Exécuter le lot\n        await batch.commit();\n        processedCount += batchSize;\n        console.log(`✅ Lot de ${batchSize} documents importés (${processedCount}/${totalDocuments})`);\n      }\n      \n      console.log(`✅ Importation terminée: ${importedCount} documents importés dans la collection ${collectionName}`);\n      return importedCount;\n    } catch (error) {\n      console.error(`❌ Erreur lors de l'importation des données CSV:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Importe des données au format JSON vers une collection Firebase\n   * @param collectionName Nom de la collection cible\n   * @param jsonData Données JSON à importer\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */\n  async importJSONToCollection(\n    collectionName: string, \n    jsonData: any[],\n    options: {\n      clearCollection?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n    } = {}\n  ): Promise<number> {\n    try {\n      console.log(`🔄 Importation des données JSON vers la collection ${collectionName}...`);\n      \n      // Options par défaut\n      const { \n        clearCollection = false, \n        updateExisting = true,\n        idField = 'id'\n      } = options;\n      \n      // Vérifier si la collection existe\n      if (!this.collections.includes(collectionName)) {\n        throw new Error(`La collection ${collectionName} n'est pas valide.`);\n      }\n      \n      // Vérifier que les données sont un tableau\n      if (!Array.isArray(jsonData)) {\n        throw new Error('Les données JSON doivent être un tableau d\\'objets.');\n      }\n      \n      // Convertir les dates en Timestamp\n      const documents = jsonData.map(doc => {\n        const processedDoc: Record<string, any> = {};\n        \n        Object.entries(doc).forEach(([key, value]) => {\n          if (typeof value === 'string' && (value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/) || value.match(/^\\d{4}-\\d{2}-\\d{2}/))) {\n            // Convertir les dates ISO en Timestamp\n            try {\n              processedDoc[key] = Timestamp.fromDate(new Date(value));\n            } catch (e) {\n              console.warn(`⚠️ Impossible de convertir la date: ${value}`);\n              processedDoc[key] = value;\n            }\n          } else {\n            processedDoc[key] = value;\n          }\n        });\n        \n        return processedDoc;\n      });\n      \n      // Vider la collection si demandé\n      if (clearCollection) {\n        await this.clearCollection(collectionName);\n      }\n      \n      // Importer les documents\n      const totalDocuments = documents.length;\n      let processedCount = 0;\n      let importedCount = 0;\n      \n      while (processedCount < totalDocuments) {\n        // Créer un nouveau lot pour chaque groupe de 500 documents\n        const batch = writeBatch(db);\n        const batchSize = Math.min(500, totalDocuments - processedCount);\n        \n        // Ajouter les documents au lot\n        for (let i = 0; i < batchSize; i++) {\n          const document = documents[processedCount + i];\n          const docId = document[idField];\n          \n          if (docId && updateExisting) {\n            // Mettre à jour ou créer le document avec l'ID spécifié\n            const docRef = doc(db, collectionName, docId);\n            batch.set(docRef, document);\n          } else {\n            // Créer un nouveau document avec un ID généré\n            const collectionRef = collection(db, collectionName);\n            const newDocRef = doc(collectionRef);\n            batch.set(newDocRef, document);\n          }\n          \n          importedCount++;\n        }\n        \n        // Exécuter le lot\n        await batch.commit();\n        processedCount += batchSize;\n        console.log(`✅ Lot de ${batchSize} documents importés (${processedCount}/${totalDocuments})`);\n      }\n      \n      console.log(`✅ Importation terminée: ${importedCount} documents importés dans la collection ${collectionName}`);\n      return importedCount;\n    } catch (error) {\n      console.error(`❌ Erreur lors de l'importation des données JSON:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Importe des données depuis un fichier ZIP contenant plusieurs collections\n   * @param zipContent Contenu du fichier ZIP\n   * @param options Options d'importation\n   * @returns Nombre de documents importés par collection\n   */\n  async importFromZip(\n    zipContent: ArrayBuffer,\n    options: {\n      clearCollections?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n    } = {}\n  ): Promise<Record<string, number>> {\n    try {\n      console.log('🔄 Importation des données depuis le fichier ZIP...');\n      \n      const zip = new JSZip();\n      await zip.loadAsync(zipContent);\n      \n      const results: Record<string, number> = {};\n      \n      // Parcourir les fichiers du ZIP\n      for (const fileName in zip.files) {\n        if (zip.files[fileName].dir) continue;\n        \n        const fileExt = fileName.split('.').pop()?.toLowerCase();\n        const collectionName = fileName.split('.')[0];\n        \n        if (!this.collections.includes(collectionName)) {\n          console.warn(`⚠️ Collection inconnue ignorée: ${collectionName}`);\n          continue;\n        }\n        \n        const fileContent = await zip.files[fileName].async('string');\n        \n        if (fileExt === 'json') {\n          try {\n            const jsonData = JSON.parse(fileContent);\n            const count = await this.importJSONToCollection(collectionName, jsonData, options);\n            results[collectionName] = count;\n          } catch (e) {\n            console.error(`❌ Erreur lors de l'importation du fichier JSON ${fileName}:`, e);\n          }\n        } else if (fileExt === 'csv') {\n          try {\n            const count = await this.importCSVToCollection(collectionName, fileContent, options);\n            results[collectionName] = count;\n          } catch (e) {\n            console.error(`❌ Erreur lors de l'importation du fichier CSV ${fileName}:`, e);\n          }\n        } else {\n          console.warn(`⚠️ Type de fichier non pris en charge: ${fileExt}`);\n        }\n      }\n      \n      console.log('✅ Importation depuis ZIP terminée:', results);\n      return results;\n    } catch (error) {\n      console.error('❌ Erreur lors de l\\'importation depuis le fichier ZIP:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Vide une collection\n   * @param collectionName Nom de la collection à vider\n   */\n  private async clearCollection(collectionName: string): Promise<void> {\n    try {\n      console.log(`🔄 Suppression des documents existants dans la collection ${collectionName}...`);\n      \n      const collectionRef = collection(db, collectionName);\n      const snapshot = await getDocs(collectionRef);\n      \n      if (snapshot.empty) {\n        console.log(`ℹ️ La collection ${collectionName} est déjà vide.`);\n        return;\n      }\n      \n      // Traiter les documents par lots de 500 (limite Firestore)\n      const documents = snapshot.docs;\n      const totalDocuments = documents.length;\n      let processedCount = 0;\n      \n      while (processedCount < totalDocuments) {\n        // Créer un nouveau lot pour chaque groupe de 500 documents\n        const batch = writeBatch(db);\n        const batchSize = Math.min(500, totalDocuments - processedCount);\n        \n        // Ajouter les suppressions au lot\n        for (let i = 0; i < batchSize; i++) {\n          const document = documents[processedCount + i];\n          batch.delete(doc(db, collectionName, document.id));\n        }\n        \n        // Exécuter le lot\n        await batch.commit();\n        processedCount += batchSize;\n        console.log(`✅ Lot de ${batchSize} documents supprimés (${processedCount}/${totalDocuments})`);\n      }\n      \n      console.log(`✅ Collection ${collectionName} vidée avec succès.`);\n    } catch (error) {\n      console.error(`❌ Erreur lors de la suppression des documents:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Analyse une ligne CSV en tenant compte des guillemets\n   * @param line Ligne CSV à analyser\n   * @returns Tableau des valeurs\n   */\n  private parseCSVLine(line: string): string[] {\n    // Si la ligne est vide, retourner un tableau vide\n    if (!line || line.trim() === '') {\n      return [];\n    }\n    \n    // Supprimer TOUS les caractères \"ë\" de la ligne avant tout traitement\n    let cleanedLine = line.replace(/ë/g, '');\n    cleanedLine = cleanedLine.replace(/Ë/g, '');\n    \n    // Détecter le séparateur le plus probable pour cette ligne\n    let separator = ';'; // On définit le point-virgule comme séparateur par défaut\n    const tabCount = (cleanedLine.match(/\\t/g) || []).length;\n    const semicolonCount = (cleanedLine.match(/;/g) || []).length;\n    const commaCount = (cleanedLine.match(/,/g) || []).length;\n    \n    if (tabCount > 0 && tabCount >= semicolonCount && tabCount >= commaCount) {\n      separator = '\\t';\n    } else if (commaCount > semicolonCount) {\n      separator = ',';\n    }\n    \n    // Diviser la ligne en utilisant le séparateur détecté\n    const values = cleanedLine.split(separator).map(value => {\n      // Nettoyer chaque valeur\n      let cleanValue = value.trim();\n      \n      // Supprimer les guillemets en début et fin si présents\n      if (cleanValue.startsWith('\"') && cleanValue.endsWith('\"')) {\n        cleanValue = cleanValue.slice(1, -1);\n      }\n      \n      // Remplacer les doubles guillemets par des simples\n      cleanValue = cleanValue.replace(/\"\"/g, '\"');\n      \n      return cleanValue;\n    });\n    \n    // Afficher des informations de débogage\n    console.log(`Ligne nettoyée: \"${cleanedLine}\"`);\n    console.log(`Valeurs extraites: ${JSON.stringify(values)}`);\n    \n    return values;\n  }\n  \n  /**\n   * Normalise l'encodage des caractères spéciaux\n   * @param text Texte à normaliser\n   * @returns Texte normalisé\n   */\n  private normalizeEncoding(text: string): string {\n    if (!text) return '';\n    \n    // Supprimer tous les caractères \"ë\" et \"Ë\"\n    let result = text.replace(/[ëË]/g, '');\n    \n    // Remplacer les caractères mal encodés par leurs équivalents corrects\n    const replacements: Record<string, string> = {\n      'Ple': 'Pôle',\n      'Pole': 'Pôle',\n      'POLE': 'Pôle',\n      'Tourne': 'Tournée',\n      'TOURNEE': 'Tournée',\n      'Tournee': 'Tournée',\n      'Complment': 'Complément',\n      'Complement': 'Complément',\n      'Tlphone': 'Téléphone',\n      'Telephone': 'Téléphone',\n      'Coordonnes': 'Coordonnées',\n      'Coordonnees': 'Coordonnées'\n    };\n    \n    // Appliquer les remplacements\n    Object.entries(replacements).forEach(([pattern, replacement]) => {\n      result = result.replace(new RegExp(pattern, 'g'), replacement);\n    });\n    \n    return result;\n  }\n  \n  /**\n   * Normalise l'encodage d'un fichier CSV/TXT entier\n   * @param content Contenu du fichier\n   * @returns Contenu normalisé\n   */\n  private normalizeFileEncoding(content: string): string {\n    if (!content) return '';\n    \n    console.log('Normalisation de l\\'encodage du fichier...');\n    \n    // Supprimer tous les caractères \"ë\"\n    content = content.replace(/ë/g, '');\n    \n    // Détecter et corriger les problèmes d'encodage courants\n    const lines = content.split(/\\r?\\n/);\n    const normalizedLines = lines.map(line => {\n      // Normaliser l'encodage de chaque ligne\n      return this.normalizeEncoding(line);\n    });\n    \n    return normalizedLines.join('\\n');\n  }\n  \n  /**\n   * Détecte et corrige l'encodage d'un fichier CSV\n   * @param content Contenu du fichier\n   * @returns Contenu avec encodage corrigé\n   */\n  private detectAndFixEncoding(content: string): string {\n    if (!content) return '';\n    \n    console.log('Détection et correction de l\\'encodage...');\n    \n    // Vérifier si le contenu commence par un BOM UTF-8\n    if (content.charCodeAt(0) === 0xFEFF) {\n      console.log('BOM UTF-8 détecté, suppression...');\n      content = content.slice(1);\n    }\n    \n    // Supprimer tous les caractères \"ë\"\n    if (content.includes('ë')) {\n      console.log('Caractères \"ë\" détectés, suppression...');\n      content = content.replace(/ë/g, '');\n    }\n    \n    // Détecter les séquences typiques d'un encodage UTF-8 mal interprété\n    const hasUtf8MisinterpretedSequences = \n      content.includes('Ã©') || // é\n      content.includes('Ã¨') || // è\n      content.includes('Ãª') || // ê\n      content.includes('Ã ') || // à\n      content.includes('Ã§') || // ç\n      content.includes('Ã´') || // ô\n      content.includes('Ã®') || // î\n      content.includes('Ã¯') || // ï\n      content.includes('Ã¼') || // ü\n      content.includes('Ã¹') || // ù\n      content.includes('Ã»') || // û\n      content.includes('Ã¢') || // â\n      content.includes('Ã«') || // ë\n      content.includes('Ã‰') || // É\n      content.includes('Ã\"'); // Ô\n    \n    if (hasUtf8MisinterpretedSequences) {\n      console.log('Séquences UTF-8 mal interprétées détectées, correction...');\n      \n      // Corriger les séquences UTF-8 mal interprétées\n      content = content\n        .replace(/Ã©/g, 'é')\n        .replace(/Ã¨/g, 'è')\n        .replace(/Ãª/g, 'ê')\n        .replace(/Ã /g, 'à')\n        .replace(/Ã§/g, 'ç')\n        .replace(/Ã´/g, 'ô')\n        .replace(/Ã®/g, 'î')\n        .replace(/Ã¯/g, 'ï')\n        .replace(/Ã¼/g, 'ü')\n        .replace(/Ã¹/g, 'ù')\n        .replace(/Ã»/g, 'û')\n        .replace(/Ã¢/g, 'â')\n        .replace(/Ã«/g, 'ë')\n        .replace(/Ã‰/g, 'É')\n        .replace(/Ã\"/g, 'Ô')\n        .replace(/PÃ´le/g, 'Pôle')\n        .replace(/TournÃ©e/g, 'Tournée')\n        .replace(/ComplÃ©ment d\\'adresse/g, 'Complément d\\'adresse')\n        .replace(/TÃ©lÃ©phone/g, 'Téléphone')\n        .replace(/CoordonnÃ©es/g, 'Coordonnées');\n    }\n    \n    // Détecter les caractères mal encodés spécifiques\n    const hasMissingAccents = \n      content.includes('Ple') || \n      content.includes('Tourne') || \n      content.includes('Complment');\n    \n    if (hasMissingAccents) {\n      console.log('Caractères accentués manquants détectés, correction...');\n      \n      // Corriger les caractères mal encodés\n      content = content\n        .replace(/Ple/g, 'Pôle')\n        .replace(/Tourne/g, 'Tournée')\n        .replace(/Complment d\\'adresse/g, 'Complément d\\'adresse')\n        .replace(/Complment/g, 'Complément')\n        .replace(/Tlphone/g, 'Téléphone')\n        .replace(/Coordonnes/g, 'Coordonnées');\n    }\n    \n    return content;\n  }\n  \n  /**\n   * Importe des sites depuis un fichier TXT\n   * @param txtContent Contenu du fichier TXT\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */\n  private async importSitesFromTXT(\n    txtContent: string,\n    options: {\n      clearCollection?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n    } = {}\n  ): Promise<number> {\n    try {\n      console.log('Traitement spécifique pour fichier TXT...');\n      \n      // Détecter et corriger l'encodage du fichier\n      let normalizedContent = this.detectAndFixEncoding(txtContent);\n      \n      // Normaliser l'encodage du contenu du fichier\n      normalizedContent = this.normalizeFileEncoding(normalizedContent);\n      \n      // Diviser le contenu en lignes\n      const lines = normalizedContent.split('\\n').map(line => line.trim()).filter(line => line !== '');\n      \n      if (lines.length === 0) {\n        throw new Error('Le fichier est vide.');\n      }\n      \n      const firstLine = lines[0];\n      \n      if (!firstLine) {\n        throw new Error('La première ligne du fichier est vide.');\n      }\n      \n      console.log('Première ligne du fichier TXT:', firstLine);\n      \n      // Détecter le séparateur en comptant les occurrences\n      const tabCount = (firstLine.match(/\\t/g) || []).length;\n      const semicolonCount = (firstLine.match(/;/g) || []).length;\n      const commaCount = (firstLine.match(/,/g) || []).length;\n      \n      console.log(`Séparateurs détectés - Tabulations: ${tabCount}, Points-virgules: ${semicolonCount}, Virgules: ${commaCount}`);\n      \n      // Afficher un échantillon des premières lignes pour le débogage\n      console.log('Échantillon des 3 premières lignes TXT:');\n      for (let i = 0; i < Math.min(3, lines.length); i++) {\n        console.log(`Ligne ${i}: ${lines[i]}`);\n      }\n      \n      // Pour les fichiers TXT, on privilégie la tabulation si elle est présente\n      let separator = '\\t';\n      \n      if (tabCount > 0) {\n        separator = '\\t';\n        console.log('Séparateur détecté pour TXT: tabulation');\n      } else if (semicolonCount > 0 && semicolonCount >= commaCount) {\n        separator = ';';\n        console.log('Séparateur détecté pour TXT: point-virgule');\n      } else if (commaCount > 0) {\n        separator = ',';\n        console.log('Séparateur détecté pour TXT: virgule');\n      } else {\n        console.log('Aucun séparateur standard détecté dans le fichier TXT, utilisation de la tabulation par défaut');\n      }\n      \n      // Convertir le TXT en format CSV normalisé\n      const normalizedCSV = lines.map(line => {\n        if (!line) return '';\n        \n        // Remplacer le séparateur détecté par des virgules\n        if (separator !== ',') {\n          // Gérer correctement les champs entre guillemets avec le séparateur à l'intérieur\n          const values = this.parseCSVLine(line);\n          return values.map(value => {\n            // Entourer de guillemets si la valeur contient une virgule\n            if (value.includes(',')) {\n              return `\"${value.replace(/\"/g, '\"\"')}\"`;\n            }\n            return value;\n          }).join(',');\n        }\n        \n        return line;\n      }).join('\\n');\n      \n      // Vérifier si la conversion a réussi\n      const normalizedLines = normalizedCSV.split('\\n');\n      if (normalizedLines.length < 2) {\n        throw new Error('La conversion du fichier TXT a échoué.');\n      }\n      \n      // Extraire les en-têtes\n      const headers = this.parseCSVLine(normalizedLines[0]);\n      \n      // Vérifier que le fichier contient suffisamment de colonnes\n      if (headers.length < 3) {\n        throw new Error(`Le fichier ne contient que ${headers.length} colonnes. Vérifiez le format du fichier et assurez-vous qu'il utilise des tabulations, des points-virgules ou des virgules comme séparateurs.`);\n      }\n      \n      console.log('En-têtes détectés dans le fichier TXT:', headers);\n      \n      // Traiter les lignes avec la fonction commune\n      return this.processImportLines(headers, normalizedLines, options);\n    } catch (error) {\n      console.error('❌ Erreur lors de l\\'importation des sites depuis TXT:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Affiche des informations de débogage sur un fichier CSV/TXT\n   * @param content Contenu du fichier\n   * @param fileName Nom du fichier\n   */\n  private debugFileInfo(content: string, fileName: string = 'inconnu'): void {\n    console.group(`📊 Informations de débogage pour le fichier: ${fileName}`);\n    \n    try {\n      // Informations générales\n      console.log(`Taille du contenu: ${content.length} caractères`);\n      console.log(`Type de fichier: ${fileName.endsWith('.txt') ? 'TXT' : 'CSV'}`);\n      \n      // Vérifier la présence du BOM UTF-8\n      const hasBOM = content.charCodeAt(0) === 0xFEFF;\n      console.log(`BOM UTF-8 détecté: ${hasBOM ? 'Oui' : 'Non'}`);\n      \n      // Analyser les lignes\n      const lines = content.split('\\n');\n      console.log(`Nombre de lignes: ${lines.length}`);\n      \n      if (lines.length > 0) {\n        // Analyser la première ligne (en-têtes)\n        const firstLine = lines[0].trim();\n        console.log(`Première ligne (${firstLine.length} caractères): ${firstLine.substring(0, 100)}${firstLine.length > 100 ? '...' : ''}`);\n        \n        // Détecter les séparateurs\n        const tabCount = (firstLine.match(/\\t/g) || []).length;\n        const semicolonCount = (firstLine.match(/;/g) || []).length;\n        const commaCount = (firstLine.match(/,/g) || []).length;\n        \n        console.log(`Séparateurs détectés - Tabulations: ${tabCount}, Points-virgules: ${semicolonCount}, Virgules: ${commaCount}`);\n        \n        // Détecter le séparateur le plus probable\n        let probableSeparator = ',';\n        if (tabCount > 0 && tabCount >= semicolonCount && tabCount >= commaCount) {\n          probableSeparator = '\\t';\n        } else if (semicolonCount > 0 && semicolonCount >= commaCount) {\n          probableSeparator = ';';\n        }\n        \n        console.log(`Séparateur le plus probable: ${probableSeparator === '\\t' ? 'tabulation' : probableSeparator}`);\n        \n        // Estimer le nombre de colonnes\n        const estimatedColumns = probableSeparator === '\\t' \n          ? tabCount + 1 \n          : (probableSeparator === ';' ? semicolonCount + 1 : commaCount + 1);\n        \n        console.log(`Nombre estimé de colonnes: ${estimatedColumns}`);\n        \n        // Vérifier la cohérence des lignes\n        if (lines.length > 1) {\n          const secondLine = lines[1].trim();\n          const secondLineTabCount = (secondLine.match(/\\t/g) || []).length;\n          const secondLineSemicolonCount = (secondLine.match(/;/g) || []).length;\n          const secondLineCommaCount = (secondLine.match(/,/g) || []).length;\n          \n          const secondLineColumns = probableSeparator === '\\t' \n            ? secondLineTabCount + 1 \n            : (probableSeparator === ';' ? secondLineSemicolonCount + 1 : secondLineCommaCount + 1);\n          \n          console.log(`Nombre de colonnes dans la deuxième ligne: ${secondLineColumns}`);\n          console.log(`Cohérence des colonnes: ${estimatedColumns === secondLineColumns ? 'OK' : 'PROBLÈME'}`);\n        }\n        \n        // Vérifier l'encodage des caractères spéciaux\n        const specialChars = ['é', 'è', 'ê', 'à', 'ç', 'ô', 'î', 'ï', 'ü', 'ù', 'û', 'â', 'ë'];\n        const specialCharsFound = specialChars.filter(char => content.includes(char));\n        \n        console.log(`Caractères spéciaux correctement encodés: ${specialCharsFound.length > 0 ? specialCharsFound.join(', ') : 'Aucun'}`);\n        \n        // Vérifier les séquences UTF-8 mal interprétées\n        const badSequences = ['Ã©', 'Ã¨', 'Ãª', 'Ã ', 'Ã§', 'Ã´', 'Ã®', 'Ã¯', 'Ã¼', 'Ã¹', 'Ã»', 'Ã¢', 'Ã«'];\n        const badSequencesFound = badSequences.filter(seq => content.includes(seq));\n        \n        console.log(`Séquences UTF-8 mal interprétées: ${badSequencesFound.length > 0 ? badSequencesFound.join(', ') : 'Aucune'}`);\n        \n        // Vérifier les caractères mal encodés spécifiques\n        const specificBadChars = ['Ple', 'Tourne', 'Complment'];\n        const specificBadCharsFound = specificBadChars.filter(char => content.includes(char));\n        \n        console.log(`Caractères mal encodés spécifiques: ${specificBadCharsFound.length > 0 ? specificBadCharsFound.join(', ') : 'Aucun'}`);\n      }\n    } catch (error) {\n      console.error('Erreur lors de l\\'analyse du fichier:', error);\n    } finally {\n      console.groupEnd();\n    }\n  }\n  \n  /**\n   * Importe des sites depuis un fichier CSV\n   * @param csvContent Contenu du fichier CSV\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */\n  async importSitesFromCSV(\n    csvContent: string,\n    options: {\n      clearCollection?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n      isTxtFile?: boolean;\n      fileName?: string;\n    } = {}\n  ): Promise<number> {\n    try {\n      const { \n        clearCollection = false, \n        updateExisting = true,\n        idField = 'id',\n        isTxtFile = false,\n        fileName = isTxtFile ? 'fichier.txt' : 'fichier.csv'\n      } = options;\n      \n      console.log(`Début de l'importation des sites depuis ${isTxtFile ? 'TXT' : 'CSV'}...`);\n      \n      // Afficher des informations de débogage sur le fichier\n      this.debugFileInfo(csvContent, fileName);\n      \n      // Traitement spécifique pour les fichiers TXT\n      if (isTxtFile) {\n        return this.importSitesFromTXT(csvContent, options);\n      }\n      \n      // Supprimer tous les caractères \"ë\" du contenu\n      let cleanedContent = csvContent.replace(/ë/g, '');\n      console.log('Contenu après nettoyage des caractères ë (50 premiers caractères):', cleanedContent.substring(0, 50));\n      \n      // Détecter et corriger l'encodage du fichier\n      let normalizedContent = this.detectAndFixEncoding(cleanedContent);\n      \n      // Vérifier si le contenu est encodé en UTF-8 avec BOM\n      if (csvContent.charCodeAt(0) === 0xFEFF) {\n        console.log('Détection du BOM UTF-8, suppression...');\n        normalizedContent = csvContent.slice(1);\n      }\n      \n      // Normaliser l'encodage du contenu du fichier\n      normalizedContent = this.normalizeFileEncoding(normalizedContent);\n      \n      // Diviser le contenu en lignes\n      const lines = normalizedContent.split(/\\r?\\n/).map(line => line.trim()).filter(line => line !== '');\n      \n      if (lines.length === 0) {\n        throw new Error('Le fichier est vide.');\n      }\n      \n      const firstLine = lines[0];\n      \n      if (!firstLine) {\n        throw new Error('La première ligne du fichier est vide.');\n      }\n      \n      console.log('Première ligne du fichier:', firstLine);\n      \n      // Détecter le séparateur en comptant les occurrences\n      const tabCount = (firstLine.match(/\\t/g) || []).length;\n      const semicolonCount = (firstLine.match(/;/g) || []).length;\n      const commaCount = (firstLine.match(/,/g) || []).length;\n      \n      // Initialiser la variable separator\n      let separator = ',';\n      \n      // Détecter si c'est le format spécifique de l'utilisateur\n      const isUserSpecificFormat = firstLine.includes('Pôle;Bassin;MI;Tournée') || \n                                  firstLine.includes('Pôle;Bassin;MI;Tournée;PT de rattachement') ||\n                                  firstLine.includes('Pole;Bassin;MI;Tournee') ||\n                                  firstLine.includes('ID;Pole;Bassin;MI;Tournee');\n      \n      if (isUserSpecificFormat) {\n        console.log('Format spécifique détecté: format utilisateur avec séparateur point-virgule');\n        separator = ';';\n      }\n      \n      console.log(`Séparateurs détectés - Tabulations: ${tabCount}, Points-virgules: ${semicolonCount}, Virgules: ${commaCount}`);\n      console.log(`Format détecté: ${isUserSpecificFormat ? 'Format utilisateur spécifique' : 'Format standard'}`);\n      \n      // Pour les fichiers TXT, on privilégie la tabulation si elle est présente\n      if (isTxtFile) {\n        if (tabCount > 0) {\n          separator = '\\t';\n          console.log('Séparateur détecté pour TXT: tabulation');\n        } else if (semicolonCount > 0 && semicolonCount >= commaCount) {\n          separator = ';';\n          console.log('Séparateur détecté pour TXT: point-virgule');\n        } else if (commaCount > 0) {\n          separator = ',';\n          console.log('Séparateur détecté pour TXT: virgule');\n        } else {\n          console.log('Aucun séparateur standard détecté dans le fichier TXT, utilisation de la tabulation par défaut');\n        }\n      } else {\n        // Pour les fichiers CSV, logique existante\n        if (tabCount > 0 && tabCount >= semicolonCount && tabCount >= commaCount) {\n          separator = '\\t';\n          console.log('Séparateur détecté pour CSV: tabulation');\n        } else if (semicolonCount > 0 && semicolonCount >= commaCount) {\n          separator = ';';\n          console.log('Séparateur détecté pour CSV: point-virgule');\n        } else {\n          console.log('Séparateur détecté pour CSV: virgule');\n        }\n      }\n      \n      // Afficher un échantillon des premières lignes pour le débogage\n      console.log('Échantillon des 3 premières lignes:');\n      for (let i = 0; i < Math.min(3, lines.length); i++) {\n        console.log(`Ligne ${i}: ${lines[i]}`);\n      }\n      \n      // Convertir le CSV en utilisant le séparateur détecté\n      let normalizedCSV = '';\n      \n      if (separator !== ',') {\n        normalizedCSV = lines.map(line => {\n          if (!line) return '';\n          \n          // Gérer correctement les champs entre guillemets avec le séparateur à l'intérieur\n          const result: string[] = [];\n          let current = '';\n          let inQuotes = false;\n          \n          for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n              inQuotes = !inQuotes;\n              current += char;\n            } else if (char === separator && !inQuotes) {\n              result.push(current);\n              current = '';\n            } else {\n              current += char;\n            }\n          }\n          \n          // Ajouter le dernier champ\n          result.push(current);\n          \n          return result.join(',');\n        }).join('\\n');\n      } else {\n        normalizedCSV = normalizedContent;\n      }\n      \n      // Vérifier si le fichier a été correctement normalisé\n      const normalizedLines = normalizedCSV.split(/\\r?\\n/).filter(line => line.trim() !== '');\n      if (normalizedLines.length < 2) {\n        // Si la normalisation a échoué, essayer une approche différente\n        console.warn('⚠️ La normalisation standard a échoué, tentative avec une approche alternative...');\n        \n        // Utiliser directement les lignes d'origine et laisser parseCSVLine gérer les séparateurs\n        const alternativeLines = lines.filter(line => line.trim() !== '');\n        \n        if (alternativeLines.length < 2) {\n          throw new Error('Le fichier est vide ou ne contient que des en-têtes.');\n        }\n        \n        // Extraire les en-têtes avec la fonction parseCSVLine améliorée\n        const headers = this.parseCSVLine(alternativeLines[0]);\n        \n        // Vérifier que le fichier contient suffisamment de colonnes\n        if (headers.length < 3) {\n          throw new Error(`Le fichier ne contient que ${headers.length} colonnes. Vérifiez le format du fichier et assurez-vous qu'il utilise des virgules, des points-virgules ou des tabulations comme séparateurs.`);\n        }\n        \n        console.log('En-têtes détectés (approche alternative):', headers);\n        \n        // Continuer avec les lignes alternatives\n        return this.processImportLines(headers, alternativeLines, options);\n      }\n      \n      // Extraire les en-têtes\n      const headers = this.parseCSVLine(normalizedLines[0]);\n      \n      // Vérifier que le CSV contient suffisamment de colonnes\n      if (headers.length < 3) {\n        throw new Error(`Le fichier ne contient que ${headers.length} colonnes. Vérifiez le format du fichier et assurez-vous qu'il utilise des virgules, des points-virgules ou des tabulations comme séparateurs.`);\n      }\n      \n      console.log('En-têtes détectés:', headers);\n      \n      return this.processImportLines(headers, normalizedLines, options);\n    } catch (error) {\n      console.error(`❌ Erreur lors de l'importation des sites depuis ${isTxtFile ? 'TXT' : 'CSV'}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Traite les lignes importées pour extraire les documents\n   * @param headers En-têtes des colonnes\n   * @param lines Lignes de données\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */\n  private async processImportLines(\n    headers: string[],\n    lines: string[],\n    options: {\n      clearCollection?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n    } = {}\n  ): Promise<number> {\n    try {\n      const { \n        clearCollection = false, \n        updateExisting = true,\n        idField = 'id'\n      } = options;\n\n      // Récupérer tous les sites existants pour la vérification des doublons\n      const sitesRef = collection(db, 'sites');\n      const existingSites = await getDocs(sitesRef);\n      const existingSitesMap = new Map<string, any>();\n      const existingSitesByName = new Map<string, any>();\n      const existingSitesByAddress = new Map<string, any>();\n\n      existingSites.forEach(doc => {\n        const siteData = doc.data();\n        existingSitesMap.set(doc.id, siteData);\n        \n        // Index par nom normalisé\n        if (siteData.nom) {\n          const normalizedName = siteData.nom.toLowerCase().trim();\n          existingSitesByName.set(normalizedName, { id: doc.id, ...siteData });\n        }\n        \n        // Index par adresse complète normalisée\n        if (siteData.adresse && siteData.ville && siteData.codePostal) {\n          const normalizedAddress = `${siteData.adresse},${siteData.ville},${siteData.codePostal}`\n            .toLowerCase()\n            .replace(/\\s+/g, '')\n            .normalize('NFD')\n            .replace(/[\\u0300-\\u036f]/g, '');\n          existingSitesByAddress.set(normalizedAddress, { id: doc.id, ...siteData });\n        }\n      });\n      \n      // Nettoyer les en-têtes avant de les normaliser\n      const cleanedHeaders = headers.map(header => header.replace(/ë/g, ''));\n      const normalizedHeaders = this.normalizeHeaders(cleanedHeaders);\n      \n      let importCount = 0;\n      let skipCount = 0;\n      let updateCount = 0;\n      \n      // Traiter les lignes par lots de 500\n      const BATCH_SIZE = 500;\n      const totalLines = lines.length - 1; // Exclure l'en-tête\n      \n      for (let startIndex = 1; startIndex < lines.length; startIndex += BATCH_SIZE) {\n        // Créer un nouveau batch pour chaque groupe\n        const batch = writeBatch(db);\n        let batchCount = 0;\n        \n        const endIndex = Math.min(startIndex + BATCH_SIZE, lines.length);\n        \n        for (let i = startIndex; i < endIndex; i++) {\n          const line = lines[i];\n          if (!line.trim()) continue;\n          \n          const values = this.parseCSVLine(line);\n          const document: Record<string, any> = {};\n          \n          // Construire le document à partir des valeurs\n          normalizedHeaders.forEach((header, index) => {\n            if (header && values[index]) {\n              document[header] = this.normalizeValue(values[index].trim(), header);\n            }\n          });\n\n          // Vérifier si le site existe déjà\n          let existingSite = null;\n\n          // 1. Vérifier par ID si disponible\n          if (document.id) {\n            existingSite = existingSitesMap.get(document.id);\n          }\n\n          // 2. Vérifier par nom normalisé\n          if (!existingSite && document.nom) {\n            const normalizedName = document.nom.toLowerCase().trim();\n            existingSite = existingSitesByName.get(normalizedName);\n          }\n\n          // 3. Vérifier par adresse complète\n          if (!existingSite && document.adresse && document.ville && document.codePostal) {\n            const normalizedAddress = `${document.adresse},${document.ville},${document.codePostal}`\n              .toLowerCase()\n              .replace(/\\s+/g, '')\n              .normalize('NFD')\n              .replace(/[\\u0300-\\u036f]/g, '');\n            existingSite = existingSitesByAddress.get(normalizedAddress);\n          }\n\n          // Si le site existe déjà\n          if (existingSite) {\n            if (!updateExisting) {\n              skipCount++;\n              continue;\n            }\n\n            // Vérifier si les données sont différentes avant de mettre à jour\n            const hasChanges = Object.keys(document).some(key => \n              document[key] !== existingSite[key] && document[key] !== undefined\n            );\n\n            if (!hasChanges) {\n              skipCount++;\n              continue;\n            }\n\n            // Mettre à jour le site existant\n            const siteRef = doc(db, 'sites', existingSite.id);\n            batch.set(siteRef, document);\n            updateCount++;\n            batchCount++;\n          } else {\n            // Créer un nouveau site\n            const newSiteRef = doc(collection(db, 'sites'));\n            batch.set(newSiteRef, document);\n            importCount++;\n            batchCount++;\n          }\n        }\n\n        // Commiter le batch s'il contient des opérations\n        if (batchCount > 0) {\n          await batch.commit();\n          console.log(`Lot de ${batchCount} documents traité (${startIndex}/${totalLines})`);\n        }\n      }\n\n      console.log(`\n        Importation terminée:\n        - ${importCount} nouveaux sites importés\n        - ${updateCount} sites mis à jour\n        - ${skipCount} sites ignorés (doublons ou sans changements)\n      `);\n\n      return importCount + updateCount;\n    } catch (error) {\n      console.error('Erreur lors du traitement des lignes:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Normalise les en-têtes pour corriger les problèmes d'encodage\n   * @param headers Tableau des en-têtes\n   * @returns Tableau des en-têtes normalisés\n   */\n  private normalizeHeaders(headers: string[]): string[] {\n    console.log('Normalisation des en-têtes...');\n    console.log('En-têtes originaux:', headers);\n    \n    // Mapping complet des en-têtes\n    const headerReplacements: Record<string, string> = {\n      // Variations de Pôle\n      'pole': 'pole',\n      'pôle': 'pole',\n      'pôles': 'pole',\n      'poles': 'pole',\n      'ple': 'pole',\n      'p le': 'pole',\n      'p.le': 'pole',\n      'p?le': 'pole',\n      \n      // Variations de Type\n      'type': 'type',\n      'type de site': 'type',\n      'type site': 'type',\n      'categorie': 'type',\n      'catégorie': 'type',\n      \n      // Variations de Nom\n      'nom': 'nom',\n      'nom site': 'nom',\n      'site': 'nom',\n      'nom du site': 'nom',\n      'denomination': 'nom',\n      'dénomination': 'nom',\n      \n      // Variations d'Adresse\n      'adresse': 'adresse',\n      'adresses': 'adresse',\n      'adr': 'adresse',\n      'adresse site': 'adresse',\n      'adresse complete': 'adresse',\n      'adresse complète': 'adresse',\n      \n      // Variations de Complément d'adresse\n      'complement': 'complementAdresse',\n      'complément': 'complementAdresse',\n      'complement adresse': 'complementAdresse',\n      'complément adresse': 'complementAdresse',\n      'complement d\\'adresse': 'complementAdresse',\n      'complément d\\'adresse': 'complementAdresse',\n      \n      // Variations de Ville\n      'ville': 'ville',\n      'commune': 'ville',\n      'localite': 'ville',\n      'localité': 'ville',\n      'villes': 'ville',\n      \n      // Variations de Code postal\n      'cp': 'codePostal',\n      'code postal': 'codePostal',\n      'code_postal': 'codePostal',\n      'codepostal': 'codePostal',\n      'cp site': 'codePostal',\n      \n      // Variations de Pays\n      'pays': 'pays',\n      'country': 'pays',\n      'nation': 'pays',\n      \n      // Variations de Téléphone\n      'tel': 'telephone',\n      'tél': 'telephone',\n      'telephone': 'telephone',\n      'téléphone': 'telephone',\n      'num tel': 'telephone',\n      'numéro': 'telephone',\n      \n      // Variations d'Email\n      'email': 'email',\n      'e-mail': 'email',\n      'mail': 'email',\n      'courriel': 'email',\n      'adresse mail': 'email',\n      \n      // Variations de Status\n      'status': 'statut',\n      'statut': 'statut',\n      'etat': 'statut',\n      'état': 'statut',\n      \n      // Variations de Tournée\n      'tournee': 'tournees',\n      'tournée': 'tournees',\n      'tournees': 'tournees',\n      'tournées': 'tournees',\n      \n      // Variations de MI\n      'mi': 'mi',\n      'responsable': 'mi',\n      'responsable mi': 'mi',\n      \n      // Variations de Bassin\n      'bassin': 'bassin',\n      'zone': 'bassin',\n      'secteur': 'bassin',\n      \n      // Autres champs\n      'id': 'id',\n      'identifiant': 'id',\n      'reference': 'id',\n      'référence': 'id',\n      'horaires lv': 'horairesLV',\n      'horaire lv': 'horairesLV',\n      'horaires semaine': 'horairesLV',\n      'horaires sam': 'horairesSamedi',\n      'horaire sam': 'horairesSamedi',\n      'horaires samedi': 'horairesSamedi'\n    };\n    \n    // Nettoyer et normaliser les en-têtes\n    const normalizedHeaders = headers.map(header => {\n      // Nettoyage initial\n      const cleanHeader = header\n        .trim()\n        .toLowerCase()\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '') // Supprimer les accents\n        .replace(/[^a-z0-9\\s]/g, ' ') // Garder uniquement les lettres, chiffres et espaces\n        .replace(/\\s+/g, ' ') // Normaliser les espaces\n        .trim();\n      \n      // Rechercher dans le mapping\n      const mappedHeader = headerReplacements[cleanHeader];\n      \n      if (mappedHeader) {\n        console.log(`En-tête normalisé: \"${header}\" -> \"${mappedHeader}\"`);\n        return mappedHeader;\n      }\n      \n      // Si pas trouvé dans le mapping, retourner la version nettoyée\n      console.log(`En-tête non mappé: \"${header}\" -> \"${cleanHeader}\"`);\n      return cleanHeader;\n    });\n    \n    console.log('En-têtes finaux après normalisation:', normalizedHeaders);\n    return normalizedHeaders;\n  }\n  \n  /**\n   * Normalise les valeurs des colonnes\n   * @param value Valeur à normaliser\n   * @param fieldName Nom du champ\n   * @returns Valeur normalisée\n   */\n  private normalizeValue(value: string, fieldName: string): string {\n    if (!value) return '';\n    \n    // Supprimer les caractères spéciaux et les espaces en trop\n    let normalizedValue = value.trim()\n      .replace(/[ëË]/g, '')\n      .replace(/\\s+/g, ' ');\n\n    // Normalisation spécifique selon le type de champ\n    switch (fieldName.toLowerCase()) {\n      case 'pole':\n        // Normaliser les variations de \"Pôle\"\n        normalizedValue = normalizedValue\n          .replace(/^p[oôó]le\\s*/i, '')\n          .replace(/^p\\s*[oôó]le\\s*/i, '')\n          .trim();\n        break;\n      \n      case 'type':\n        // Normaliser les types de sites\n        const lowerValue = normalizedValue.toLowerCase();\n        if (lowerValue.includes('labo') || lowerValue.includes('lab')) {\n          normalizedValue = 'Laboratoire';\n        } else if (lowerValue.includes('site')) {\n          normalizedValue = 'Site';\n        } else if (lowerValue.includes('client')) {\n          normalizedValue = 'Client';\n        } else if (lowerValue.includes('point')) {\n          normalizedValue = 'Point de collecte';\n        } else {\n          normalizedValue = normalizedValue.charAt(0).toUpperCase() + normalizedValue.slice(1).toLowerCase();\n        }\n        break;\n      \n      case 'ville':\n      case 'nom':\n        // Capitaliser chaque mot pour les villes et les noms\n        normalizedValue = normalizedValue.split(' ')\n          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n          .join(' ');\n        break;\n      \n      case 'codepostal':\n        // Nettoyer le code postal (garder uniquement les chiffres)\n        normalizedValue = normalizedValue.replace(/\\D/g, '');\n        break;\n      \n      case 'telephone':\n        // Normaliser les numéros de téléphone\n        normalizedValue = normalizedValue.replace(/\\D/g, '');\n        if (normalizedValue.length === 10) {\n          normalizedValue = normalizedValue.replace(/(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/, '$1.$2.$3.$4.$5');\n        }\n        break;\n      \n      case 'email':\n        // Mettre les emails en minuscules\n        normalizedValue = normalizedValue.toLowerCase();\n        break;\n      \n      case 'adresse':\n        // Normaliser les adresses\n        normalizedValue = normalizedValue\n          .replace(/\\s+/g, ' ')\n          .replace(/,\\s*/g, ', ')\n          .replace(/\\s*-\\s*/g, '-')\n          .trim();\n        break;\n    }\n    \n    return normalizedValue;\n  }\n  \n  /**\n   * Traite spécifiquement le format de données fourni par l'utilisateur\n   * @param csvContent Contenu du fichier CSV\n   * @param options Options d'importation\n   * @returns Nombre de documents importés\n   */\n  async importUserSpecificFormat(\n    csvContent: string,\n    options: {\n      clearCollection?: boolean;\n      updateExisting?: boolean;\n      idField?: string;\n    } = {}\n  ): Promise<number> {\n    try {\n      console.log('🔄 Importation avec le format spécifique de l\\'utilisateur...');\n      \n      // Options par défaut\n      const { \n        clearCollection = false, \n        updateExisting = true,\n        idField = 'id'\n      } = options;\n      \n      // Séparer les lignes\n      const lines = csvContent.split('\\n').filter(line => line.trim() !== '');\n      \n      if (lines.length < 2) {\n        throw new Error('Le fichier est vide ou ne contient que des en-têtes.');\n      }\n      \n      // Extraire et normaliser les en-têtes\n      const headers = lines[0].split(';').map(header => header.trim());\n      const normalizedHeaders = this.normalizeHeaders(headers);\n      console.log('En-têtes normalisés:', normalizedHeaders);\n      \n      // Mapper les en-têtes aux champs de la base de données\n      const fieldMap: Record<string, string> = {\n        'pole': 'pole',\n        'pôle': 'pole',\n        'tournée': 'tournees',\n        'type de site': 'type',\n        'nom': 'nom',\n        'adresse': 'adresse',\n        'complément d\\'adresse': 'complementAdresse',\n        'ville': 'ville',\n        'code postal': 'codePostal',\n        'pays': 'pays',\n        'horaire d\\'ouverture - lundi - vendredi': 'horairesLV',\n        'horaire d\\'ouverture - samedi -': 'horairesSamedi',\n        'id': 'id'\n      };\n      \n      // Créer un mapping des indices de colonnes vers les noms de champs\n      const columnMap: Record<number, string> = {};\n      normalizedHeaders.forEach((header, index) => {\n        const mappedField = fieldMap[header.toLowerCase()];\n        if (mappedField) {\n          columnMap[index] = mappedField;\n          console.log(`Mapped header \"${header}\" to field \"${mappedField}\"`);\n        } else {\n          console.log(`No mapping found for header \"${header}\"`);\n        }\n      });\n      \n      // Préparer les documents\n      const documents: Record<string, any>[] = [];\n      \n      // Traiter chaque ligne (sauf la première qui contient les en-têtes)\n      for (let i = 1; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        \n        // Diviser la ligne en valeurs\n        const values = line.split(';');\n        \n        // Créer un document avec les valeurs par défaut\n        const doc: Record<string, any> = {\n          pole: '',\n          nom: '',\n          type: 'Laboratoire',\n          adresse: '',\n          ville: '',\n          codePostal: '',\n          telephone: '',\n          email: '',\n          codeBarres: '',\n          tournees: [],\n          codesPorte: '',\n          coordonnees: '',\n          statut: 'actif',\n          complementAdresse: '',\n          pays: 'France',\n          horairesLV: '',\n          horairesSamedi: ''\n        };\n        \n        // Remplir le document avec les valeurs de la ligne\n        let hasValidName = false;\n        \n        for (let j = 0; j < values.length; j++) {\n          const fieldName = columnMap[j];\n          if (!fieldName) continue;\n          \n          let value = values[j].trim();\n          \n          // Traitement spécial pour certains champs\n          if (fieldName === 'tournees' && value) {\n            // Convertir en tableau\n            value = [value];\n          } else if (fieldName === 'type' && value) {\n            // Standardiser le type\n            const lowerValue = value.toLowerCase();\n            if (lowerValue.includes('labo') || lowerValue.includes('lab')) {\n              value = 'Laboratoire';\n            } else if (lowerValue.includes('site')) {\n              value = 'Site';\n            } else if (lowerValue.includes('client')) {\n              value = 'Client';\n            } else if (lowerValue.includes('point')) {\n              value = 'Point de collecte';\n            } else {\n              value = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();\n            }\n          }\n          \n          // Assigner la valeur au document\n          if (value !== '') {\n            doc[fieldName] = value;\n            \n            // Vérifier si nous avons un nom valide\n            if (fieldName === 'nom' && value) {\n              hasValidName = true;\n            }\n          }\n        }\n        \n        // Si nous n'avons pas de nom mais avons une adresse, utiliser l'adresse comme nom\n        if (!hasValidName && !doc.nom && doc.adresse) {\n          doc.nom = `Site - ${doc.adresse}`;\n          hasValidName = true;\n        }\n        \n        // Ajouter le document s'il a un nom ou un ID\n        if (hasValidName || doc.id) {\n          documents.push(doc);\n        } else {\n          console.warn(`⚠️ Ligne ${i + 1} ignorée: aucun nom ou identifiant valide trouvé`);\n        }\n      }\n      \n      if (documents.length === 0) {\n        throw new Error('Aucun document valide n\\'a pu être extrait du fichier.');\n      }\n      \n      console.log(`✅ ${documents.length} sites valides extraits du fichier`);\n      \n      // Vider la collection si demandé\n      if (clearCollection) {\n        await this.clearCollection('sites');\n      }\n      \n      // Importer les documents\n      const totalDocuments = documents.length;\n      let processedCount = 0;\n      let importedCount = 0;\n      \n      while (processedCount < totalDocuments) {\n        // Créer un nouveau lot pour chaque groupe de 500 documents\n        const batch = writeBatch(db);\n        const batchSize = Math.min(500, totalDocuments - processedCount);\n        \n        // Ajouter les documents au lot\n        for (let i = 0; i < batchSize; i++) {\n          const document = documents[processedCount + i];\n          const docId = document[idField];\n          \n          if (docId && updateExisting) {\n            // Mettre à jour ou créer le document avec l'ID spécifié\n            const docRef = doc(db, 'sites', docId);\n            batch.set(docRef, document);\n          } else {\n            // Créer un nouveau document avec un ID généré\n            const collectionRef = collection(db, 'sites');\n            const newDocRef = doc(collectionRef);\n            batch.set(newDocRef, document);\n          }\n          \n          importedCount++;\n        }\n        \n        // Exécuter le lot\n        await batch.commit();\n        processedCount += batchSize;\n        console.log(`✅ Lot de ${batchSize} sites importés (${processedCount}/${totalDocuments})`);\n      }\n      \n      console.log(`✅ Importation terminée: ${importedCount} sites importés`);\n      return importedCount;\n    } catch (error) {\n      console.error('❌ Erreur lors de l\\'importation avec le format spécifique:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new SharePointService(); \r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}