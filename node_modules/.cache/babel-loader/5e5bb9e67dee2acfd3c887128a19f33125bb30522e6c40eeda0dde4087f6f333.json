{"ast":null,"code":"import { collection, getDocs, addDoc, updateDoc, deleteDoc, doc, query, where, orderBy, getDoc } from 'firebase/firestore';\nimport { ref, uploadBytesResumable, getDownloadURL, deleteObject } from 'firebase/storage';\nimport { db, storage } from '../config/firebase';\nclass VehicleInspectionService {\n  constructor() {\n    this.collection = 'vehicleInspections';\n    this.storageBasePath = 'vehicle-inspections';\n  }\n  // Récupérer toutes les inspections avec filtres optionnels\n  async getInspections(filters = {}) {\n    try {\n      const inspectionsRef = collection(db, this.collection);\n      let q = query(inspectionsRef, orderBy('date', 'desc'));\n      if (filters.vehicleId) {\n        q = query(q, where('vehicleId', '==', filters.vehicleId));\n      }\n      if (filters.inspectedBy) {\n        q = query(q, where('inspectedBy', '==', filters.inspectedBy));\n      }\n      if (filters.status) {\n        q = query(q, where('status', '==', filters.status));\n      }\n      if (filters.startDate) {\n        q = query(q, where('date', '>=', filters.startDate));\n      }\n      if (filters.endDate) {\n        q = query(q, where('date', '<=', filters.endDate));\n      }\n      if (filters.actionRequired !== undefined) {\n        q = query(q, where('actionRequired', '==', filters.actionRequired));\n      }\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Erreur lors de la récupération des inspections:', error);\n      throw error;\n    }\n  }\n\n  // Récupérer une inspection par ID\n  async getInspectionById(id) {\n    try {\n      const inspectionRef = doc(db, this.collection, id);\n      const inspectionDoc = await getDoc(inspectionRef);\n      if (!inspectionDoc.exists()) {\n        return null;\n      }\n      return {\n        id: inspectionDoc.id,\n        ...inspectionDoc.data()\n      };\n    } catch (error) {\n      console.error('Erreur lors de la récupération de l\\'inspection:', error);\n      throw error;\n    }\n  }\n\n  // Créer une nouvelle inspection\n  async createInspection(inspection) {\n    try {\n      const inspectionsRef = collection(db, this.collection);\n      const now = new Date().toISOString();\n      const docRef = await addDoc(inspectionsRef, {\n        ...inspection,\n        createdAt: now,\n        updatedAt: now\n      });\n      return {\n        id: docRef.id,\n        ...inspection,\n        createdAt: now,\n        updatedAt: now\n      };\n    } catch (error) {\n      console.error('Erreur lors de la création de l\\'inspection:', error);\n      throw error;\n    }\n  }\n\n  // Mettre à jour une inspection existante\n  async updateInspection(id, inspection) {\n    try {\n      const inspectionRef = doc(db, this.collection, id);\n      await updateDoc(inspectionRef, {\n        ...inspection,\n        updatedAt: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Erreur lors de la mise à jour de l\\'inspection:', error);\n      throw error;\n    }\n  }\n\n  // Supprimer une inspection\n  async deleteInspection(id) {\n    try {\n      // D'abord, récupérer l'inspection pour obtenir toutes les photos\n      const inspection = await this.getInspectionById(id);\n      if (inspection) {\n        // Supprimer toutes les photos de chaque élément d'inspection\n        for (const item of inspection.inspectionItems) {\n          for (const photo of item.photos) {\n            await this.deletePhoto(photo.url);\n          }\n        }\n      }\n\n      // Supprimer le document de l'inspection\n      const inspectionRef = doc(db, this.collection, id);\n      await deleteDoc(inspectionRef);\n    } catch (error) {\n      console.error('Erreur lors de la suppression de l\\'inspection:', error);\n      throw error;\n    }\n  }\n\n  // Uploader une photo\n  async uploadPhoto(file, vehicleId, inspectionItemId) {\n    try {\n      const timestamp = Date.now();\n      const fileName = `${vehicleId}_${inspectionItemId}_${timestamp}_${file.name.replace(/[^a-zA-Z0-9.]/g, '_')}`;\n      const filePath = `${this.storageBasePath}/photos/${fileName}`;\n      const storageRef = ref(storage, filePath);\n\n      // Upload le fichier avec progression\n      const uploadTask = uploadBytesResumable(storageRef, file);\n      return new Promise((resolve, reject) => {\n        uploadTask.on('state_changed', snapshot => {\n          const progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n          console.log('Upload progress:', progress);\n        }, error => {\n          console.error('Erreur lors de l\\'upload:', error);\n          reject(error);\n        }, async () => {\n          try {\n            const url = await getDownloadURL(uploadTask.snapshot.ref);\n            // Créer une version miniature pour améliorer les performances\n            const thumbnailUrl = url; // Dans un projet réel, vous créeriez une véritable miniature\n\n            const photoData = {\n              id: `photo_${timestamp}`,\n              url,\n              thumbnailUrl,\n              fileName,\n              mimeType: file.type,\n              size: file.size,\n              createdAt: new Date().toISOString(),\n              metadata: {\n                width: null,\n                // À remplir avec les dimensions réelles si nécessaire\n                height: null,\n                location: null // À remplir avec les coordonnées GPS si disponibles\n              }\n            };\n            resolve(photoData);\n          } catch (error) {\n            console.error('Erreur lors de la récupération de l\\'URL:', error);\n            reject(error);\n          }\n        });\n      });\n    } catch (error) {\n      console.error('Erreur lors de l\\'upload de la photo:', error);\n      throw error;\n    }\n  }\n\n  // Ajouter une photo à un élément d'inspection\n  async addPhotoToInspectionItem(inspectionId, itemId, photo) {\n    try {\n      const inspection = await this.getInspectionById(inspectionId);\n      if (!inspection) {\n        throw new Error('Inspection non trouvée');\n      }\n\n      // Trouver l'élément d'inspection\n      const itemIndex = inspection.inspectionItems.findIndex(item => item.id === itemId);\n      if (itemIndex === -1) {\n        throw new Error('Élément d\\'inspection non trouvé');\n      }\n\n      // Ajouter la photo à l'élément\n      const updatedItems = [...inspection.inspectionItems];\n      updatedItems[itemIndex] = {\n        ...updatedItems[itemIndex],\n        photos: [...updatedItems[itemIndex].photos, photo]\n      };\n\n      // Mettre à jour l'inspection\n      await this.updateInspection(inspectionId, {\n        inspectionItems: updatedItems\n      });\n    } catch (error) {\n      console.error('Erreur lors de l\\'ajout de la photo à l\\'élément d\\'inspection:', error);\n      throw error;\n    }\n  }\n\n  // Supprimer une photo\n  async deletePhoto(photoUrl) {\n    try {\n      // Supprimer le fichier du storage\n      const fileRef = ref(storage, photoUrl);\n      await deleteObject(fileRef);\n    } catch (error) {\n      console.error('Erreur lors de la suppression de la photo:', error);\n      throw error;\n    }\n  }\n\n  // Supprimer une photo d'un élément d'inspection\n  async removePhotoFromInspectionItem(inspectionId, itemId, photoId) {\n    try {\n      const inspection = await this.getInspectionById(inspectionId);\n      if (!inspection) {\n        throw new Error('Inspection non trouvée');\n      }\n\n      // Trouver l'élément d'inspection\n      const itemIndex = inspection.inspectionItems.findIndex(item => item.id === itemId);\n      if (itemIndex === -1) {\n        throw new Error('Élément d\\'inspection non trouvé');\n      }\n\n      // Trouver la photo\n      const photoIndex = inspection.inspectionItems[itemIndex].photos.findIndex(photo => photo.id === photoId);\n      if (photoIndex === -1) {\n        throw new Error('Photo non trouvée');\n      }\n\n      // Récupérer l'URL de la photo pour la supprimer du storage\n      const photoUrl = inspection.inspectionItems[itemIndex].photos[photoIndex].url;\n      await this.deletePhoto(photoUrl);\n\n      // Supprimer la photo de l'élément\n      const updatedPhotos = inspection.inspectionItems[itemIndex].photos.filter(photo => photo.id !== photoId);\n      const updatedItems = [...inspection.inspectionItems];\n      updatedItems[itemIndex] = {\n        ...updatedItems[itemIndex],\n        photos: updatedPhotos\n      };\n\n      // Mettre à jour l'inspection\n      await this.updateInspection(inspectionId, {\n        inspectionItems: updatedItems\n      });\n    } catch (error) {\n      console.error('Erreur lors de la suppression de la photo de l\\'élément d\\'inspection:', error);\n      throw error;\n    }\n  }\n}\nexport const vehicleInspectionService = new VehicleInspectionService();","map":{"version":3,"names":["collection","getDocs","addDoc","updateDoc","deleteDoc","doc","query","where","orderBy","getDoc","ref","uploadBytesResumable","getDownloadURL","deleteObject","db","storage","VehicleInspectionService","constructor","storageBasePath","getInspections","filters","inspectionsRef","q","vehicleId","inspectedBy","status","startDate","endDate","actionRequired","undefined","snapshot","docs","map","id","data","error","console","getInspectionById","inspectionRef","inspectionDoc","exists","createInspection","inspection","now","Date","toISOString","docRef","createdAt","updatedAt","updateInspection","deleteInspection","item","inspectionItems","photo","photos","deletePhoto","url","uploadPhoto","file","inspectionItemId","timestamp","fileName","name","replace","filePath","storageRef","uploadTask","Promise","resolve","reject","on","progress","bytesTransferred","totalBytes","log","thumbnailUrl","photoData","mimeType","type","size","metadata","width","height","location","addPhotoToInspectionItem","inspectionId","itemId","Error","itemIndex","findIndex","updatedItems","photoUrl","fileRef","removePhotoFromInspectionItem","photoId","photoIndex","updatedPhotos","filter","vehicleInspectionService"],"sources":["C:/Users/LS_110/Documents/GitHub/inovie-SCAN-web-main/src/services/vehicleInspectionService.ts"],"sourcesContent":["import { collection, getDocs, addDoc, updateDoc, deleteDoc, doc, query, where, orderBy, Timestamp, getDoc } from 'firebase/firestore';\r\nimport { ref, uploadBytesResumable, getDownloadURL, deleteObject } from 'firebase/storage';\r\nimport { db, storage } from '../config/firebase';\r\nimport { VehicleInspection, InspectionItem, Photo, InspectionStatus } from '../types/Vehicle';\r\n\r\nexport interface VehicleInspectionFilters {\r\n  vehicleId?: string;\r\n  inspectedBy?: string;\r\n  status?: InspectionStatus;\r\n  startDate?: string;\r\n  endDate?: string;\r\n  actionRequired?: boolean;\r\n}\r\n\r\nclass VehicleInspectionService {\r\n  private collection = 'vehicleInspections';\r\n  private storageBasePath = 'vehicle-inspections';\r\n\r\n  // Récupérer toutes les inspections avec filtres optionnels\r\n  async getInspections(filters: VehicleInspectionFilters = {}): Promise<VehicleInspection[]> {\r\n    try {\r\n      const inspectionsRef = collection(db, this.collection);\r\n      let q = query(inspectionsRef, orderBy('date', 'desc'));\r\n\r\n      if (filters.vehicleId) {\r\n        q = query(q, where('vehicleId', '==', filters.vehicleId));\r\n      }\r\n      if (filters.inspectedBy) {\r\n        q = query(q, where('inspectedBy', '==', filters.inspectedBy));\r\n      }\r\n      if (filters.status) {\r\n        q = query(q, where('status', '==', filters.status));\r\n      }\r\n      if (filters.startDate) {\r\n        q = query(q, where('date', '>=', filters.startDate));\r\n      }\r\n      if (filters.endDate) {\r\n        q = query(q, where('date', '<=', filters.endDate));\r\n      }\r\n      if (filters.actionRequired !== undefined) {\r\n        q = query(q, where('actionRequired', '==', filters.actionRequired));\r\n      }\r\n\r\n      const snapshot = await getDocs(q);\r\n      return snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data()\r\n      })) as VehicleInspection[];\r\n    } catch (error) {\r\n      console.error('Erreur lors de la récupération des inspections:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Récupérer une inspection par ID\r\n  async getInspectionById(id: string): Promise<VehicleInspection | null> {\r\n    try {\r\n      const inspectionRef = doc(db, this.collection, id);\r\n      const inspectionDoc = await getDoc(inspectionRef);\r\n      \r\n      if (!inspectionDoc.exists()) {\r\n        return null;\r\n      }\r\n      \r\n      return {\r\n        id: inspectionDoc.id,\r\n        ...inspectionDoc.data()\r\n      } as VehicleInspection;\r\n    } catch (error) {\r\n      console.error('Erreur lors de la récupération de l\\'inspection:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Créer une nouvelle inspection\r\n  async createInspection(inspection: Omit<VehicleInspection, 'id' | 'createdAt' | 'updatedAt'>): Promise<VehicleInspection> {\r\n    try {\r\n      const inspectionsRef = collection(db, this.collection);\r\n      const now = new Date().toISOString();\r\n      \r\n      const docRef = await addDoc(inspectionsRef, {\r\n        ...inspection,\r\n        createdAt: now,\r\n        updatedAt: now\r\n      });\r\n\r\n      return {\r\n        id: docRef.id,\r\n        ...inspection,\r\n        createdAt: now,\r\n        updatedAt: now\r\n      };\r\n    } catch (error) {\r\n      console.error('Erreur lors de la création de l\\'inspection:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Mettre à jour une inspection existante\r\n  async updateInspection(id: string, inspection: Partial<VehicleInspection>): Promise<void> {\r\n    try {\r\n      const inspectionRef = doc(db, this.collection, id);\r\n      await updateDoc(inspectionRef, {\r\n        ...inspection,\r\n        updatedAt: new Date().toISOString()\r\n      });\r\n    } catch (error) {\r\n      console.error('Erreur lors de la mise à jour de l\\'inspection:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Supprimer une inspection\r\n  async deleteInspection(id: string): Promise<void> {\r\n    try {\r\n      // D'abord, récupérer l'inspection pour obtenir toutes les photos\r\n      const inspection = await this.getInspectionById(id);\r\n      if (inspection) {\r\n        // Supprimer toutes les photos de chaque élément d'inspection\r\n        for (const item of inspection.inspectionItems) {\r\n          for (const photo of item.photos) {\r\n            await this.deletePhoto(photo.url);\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Supprimer le document de l'inspection\r\n      const inspectionRef = doc(db, this.collection, id);\r\n      await deleteDoc(inspectionRef);\r\n    } catch (error) {\r\n      console.error('Erreur lors de la suppression de l\\'inspection:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Uploader une photo\r\n  async uploadPhoto(file: File, vehicleId: string, inspectionItemId: string): Promise<Photo> {\r\n    try {\r\n      const timestamp = Date.now();\r\n      const fileName = `${vehicleId}_${inspectionItemId}_${timestamp}_${file.name.replace(/[^a-zA-Z0-9.]/g, '_')}`;\r\n      const filePath = `${this.storageBasePath}/photos/${fileName}`;\r\n      const storageRef = ref(storage, filePath);\r\n\r\n      // Upload le fichier avec progression\r\n      const uploadTask = uploadBytesResumable(storageRef, file);\r\n\r\n      return new Promise((resolve, reject) => {\r\n        uploadTask.on('state_changed',\r\n          (snapshot) => {\r\n            const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n            console.log('Upload progress:', progress);\r\n          },\r\n          (error) => {\r\n            console.error('Erreur lors de l\\'upload:', error);\r\n            reject(error);\r\n          },\r\n          async () => {\r\n            try {\r\n              const url = await getDownloadURL(uploadTask.snapshot.ref);\r\n              // Créer une version miniature pour améliorer les performances\r\n              const thumbnailUrl = url; // Dans un projet réel, vous créeriez une véritable miniature\r\n              \r\n              const photoData: Photo = {\r\n                id: `photo_${timestamp}`,\r\n                url,\r\n                thumbnailUrl,\r\n                fileName,\r\n                mimeType: file.type,\r\n                size: file.size,\r\n                createdAt: new Date().toISOString(),\r\n                metadata: {\r\n                  width: null, // À remplir avec les dimensions réelles si nécessaire\r\n                  height: null,\r\n                  location: null // À remplir avec les coordonnées GPS si disponibles\r\n                }\r\n              };\r\n              \r\n              resolve(photoData);\r\n            } catch (error) {\r\n              console.error('Erreur lors de la récupération de l\\'URL:', error);\r\n              reject(error);\r\n            }\r\n          }\r\n        );\r\n      });\r\n    } catch (error) {\r\n      console.error('Erreur lors de l\\'upload de la photo:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Ajouter une photo à un élément d'inspection\r\n  async addPhotoToInspectionItem(\r\n    inspectionId: string, \r\n    itemId: string, \r\n    photo: Photo\r\n  ): Promise<void> {\r\n    try {\r\n      const inspection = await this.getInspectionById(inspectionId);\r\n      if (!inspection) {\r\n        throw new Error('Inspection non trouvée');\r\n      }\r\n      \r\n      // Trouver l'élément d'inspection\r\n      const itemIndex = inspection.inspectionItems.findIndex(item => item.id === itemId);\r\n      if (itemIndex === -1) {\r\n        throw new Error('Élément d\\'inspection non trouvé');\r\n      }\r\n      \r\n      // Ajouter la photo à l'élément\r\n      const updatedItems = [...inspection.inspectionItems];\r\n      updatedItems[itemIndex] = {\r\n        ...updatedItems[itemIndex],\r\n        photos: [...updatedItems[itemIndex].photos, photo]\r\n      };\r\n      \r\n      // Mettre à jour l'inspection\r\n      await this.updateInspection(inspectionId, {\r\n        inspectionItems: updatedItems\r\n      });\r\n    } catch (error) {\r\n      console.error('Erreur lors de l\\'ajout de la photo à l\\'élément d\\'inspection:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Supprimer une photo\r\n  async deletePhoto(photoUrl: string): Promise<void> {\r\n    try {\r\n      // Supprimer le fichier du storage\r\n      const fileRef = ref(storage, photoUrl);\r\n      await deleteObject(fileRef);\r\n    } catch (error) {\r\n      console.error('Erreur lors de la suppression de la photo:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Supprimer une photo d'un élément d'inspection\r\n  async removePhotoFromInspectionItem(\r\n    inspectionId: string,\r\n    itemId: string,\r\n    photoId: string\r\n  ): Promise<void> {\r\n    try {\r\n      const inspection = await this.getInspectionById(inspectionId);\r\n      if (!inspection) {\r\n        throw new Error('Inspection non trouvée');\r\n      }\r\n      \r\n      // Trouver l'élément d'inspection\r\n      const itemIndex = inspection.inspectionItems.findIndex(item => item.id === itemId);\r\n      if (itemIndex === -1) {\r\n        throw new Error('Élément d\\'inspection non trouvé');\r\n      }\r\n      \r\n      // Trouver la photo\r\n      const photoIndex = inspection.inspectionItems[itemIndex].photos.findIndex(photo => photo.id === photoId);\r\n      if (photoIndex === -1) {\r\n        throw new Error('Photo non trouvée');\r\n      }\r\n      \r\n      // Récupérer l'URL de la photo pour la supprimer du storage\r\n      const photoUrl = inspection.inspectionItems[itemIndex].photos[photoIndex].url;\r\n      await this.deletePhoto(photoUrl);\r\n      \r\n      // Supprimer la photo de l'élément\r\n      const updatedPhotos = inspection.inspectionItems[itemIndex].photos.filter(photo => photo.id !== photoId);\r\n      const updatedItems = [...inspection.inspectionItems];\r\n      updatedItems[itemIndex] = {\r\n        ...updatedItems[itemIndex],\r\n        photos: updatedPhotos\r\n      };\r\n      \r\n      // Mettre à jour l'inspection\r\n      await this.updateInspection(inspectionId, {\r\n        inspectionItems: updatedItems\r\n      });\r\n    } catch (error) {\r\n      console.error('Erreur lors de la suppression de la photo de l\\'élément d\\'inspection:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport const vehicleInspectionService = new VehicleInspectionService(); \r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}