{"ast":null,"code":"import { db } from '../config/firebase';\nimport { collection, getDocs, query, where, Timestamp, doc, writeBatch } from 'firebase/firestore';\nimport SharePointService from './SharePointService';\nimport JSZip from 'jszip';\n\n/**\n * Service pour g√©rer les fonctionnalit√©s d'administration\n */\nexport class AdminService {\n  constructor() {\n    // Collections Firebase\n    this.collections = ['passages', 'sites', 'tournees', 'vehicules', 'users'];\n  }\n  /**\n   * R√©cup√®re les statistiques des collections\n   * @returns Statistiques des collections\n   */\n  async getCollectionsStats() {\n    try {\n      console.log('üîÑ R√©cup√©ration des statistiques des collections...');\n      const stats = {};\n      for (const collectionName of this.collections) {\n        const querySnapshot = await getDocs(collection(db, collectionName));\n        stats[collectionName] = querySnapshot.size;\n      }\n      console.log('‚úÖ Statistiques r√©cup√©r√©es:', stats);\n      return stats;\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la r√©cup√©ration des statistiques:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cr√©e une sauvegarde compl√®te de la base de donn√©es\n   * @returns Fichier ZIP contenant toutes les collections\n   */\n  async createFullBackup() {\n    try {\n      console.log('üîÑ Cr√©ation d\\'une sauvegarde compl√®te...');\n\n      // Utiliser le service SharePoint pour g√©n√©rer la sauvegarde\n      await SharePointService.generateCompleteBackup();\n      console.log('‚úÖ Sauvegarde compl√®te cr√©√©e avec succ√®s');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la cr√©ation de la sauvegarde compl√®te:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cr√©e une sauvegarde s√©lective de certaines collections\n   * @param selectedCollections Collections √† sauvegarder\n   */\n  async createSelectiveBackup(selectedCollections) {\n    try {\n      console.log(`üîÑ Cr√©ation d'une sauvegarde s√©lective pour les collections: ${selectedCollections.join(', ')}...`);\n\n      // V√©rifier que les collections s√©lectionn√©es sont valides\n      const validCollections = selectedCollections.filter(col => this.collections.includes(col));\n      if (validCollections.length === 0) {\n        throw new Error('Aucune collection valide s√©lectionn√©e pour la sauvegarde');\n      }\n\n      // Cr√©er un objet ZIP\n      const zip = new JSZip();\n\n      // Ajouter chaque collection s√©lectionn√©e au ZIP\n      for (const collectionName of validCollections) {\n        const data = await SharePointService.exportCollectionToJSON(collectionName);\n        if (data && data.length > 0) {\n          zip.file(`${collectionName}.json`, JSON.stringify(data, null, 2));\n        }\n      }\n\n      // G√©n√©rer le fichier ZIP\n      const content = await zip.generateAsync({\n        type: 'blob'\n      });\n\n      // T√©l√©charger le fichier\n      const url = URL.createObjectURL(content);\n      const link = document.createElement('a');\n      link.setAttribute('href', url);\n      link.setAttribute('download', `selective_backup_${new Date().toISOString().split('T')[0]}.zip`);\n      link.style.visibility = 'hidden';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      console.log('‚úÖ Sauvegarde s√©lective cr√©√©e avec succ√®s');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la cr√©ation de la sauvegarde s√©lective:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Nettoie les donn√©es obsol√®tes d'une collection\n   * @param collectionName Nom de la collection √† nettoyer\n   * @param olderThan Date limite (les documents plus anciens seront supprim√©s)\n   * @returns Nombre de documents supprim√©s\n   */\n  async cleanupObsoleteData(collectionName, olderThan) {\n    try {\n      console.log(`üîÑ Nettoyage des donn√©es obsol√®tes de la collection ${collectionName}...`);\n\n      // V√©rifier que la collection est valide\n      if (!this.collections.includes(collectionName)) {\n        throw new Error(`La collection ${collectionName} n'est pas valide`);\n      }\n\n      // Convertir la date en Timestamp\n      const olderThanTimestamp = Timestamp.fromDate(olderThan);\n\n      // R√©cup√©rer les documents √† supprimer\n      const collectionRef = collection(db, collectionName);\n      let queryRef;\n\n      // Adapter la requ√™te en fonction de la collection\n      if (collectionName === 'passages') {\n        queryRef = query(collectionRef, where('date', '<', olderThanTimestamp));\n      } else if (collectionName === 'users') {\n        queryRef = query(collectionRef, where('lastLogin', '<', olderThanTimestamp));\n      } else {\n        queryRef = query(collectionRef, where('updatedAt', '<', olderThanTimestamp));\n      }\n      const snapshot = await getDocs(queryRef);\n      if (snapshot.empty) {\n        console.log(`‚ÑπÔ∏è Aucune donn√©e obsol√®te trouv√©e dans la collection ${collectionName}`);\n        return 0;\n      }\n\n      // Supprimer les documents\n      const batch = writeBatch(db);\n      let batchCount = 0;\n      snapshot.docs.forEach(document => {\n        batch.delete(doc(db, collectionName, document.id));\n        batchCount++;\n\n        // Ex√©cuter le batch toutes les 500 op√©rations (limite Firestore)\n        if (batchCount >= 500) {\n          batch.commit();\n          console.log(`‚úÖ Lot de ${batchCount} documents supprim√©s`);\n          batchCount = 0;\n        }\n      });\n\n      // Ex√©cuter le dernier batch s'il reste des op√©rations\n      if (batchCount > 0) {\n        await batch.commit();\n        console.log(`‚úÖ Dernier lot de ${batchCount} documents supprim√©s`);\n      }\n      console.log(`‚úÖ Nettoyage termin√©: ${snapshot.size} documents supprim√©s de la collection ${collectionName}`);\n      return snapshot.size;\n    } catch (error) {\n      console.error(`‚ùå Erreur lors du nettoyage des donn√©es obsol√®tes:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Optimise les index de la base de donn√©es\n   * Cette fonction est simul√©e car Firestore g√®re automatiquement ses index\n   */\n  async optimizeIndexes() {\n    try {\n      console.log('üîÑ Optimisation des index...');\n\n      // Simuler une op√©ration d'optimisation\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      console.log('‚úÖ Optimisation des index termin√©e');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de l\\'optimisation des index:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * R√©initialise la base de donn√©es (DANGER)\n   * @param confirmation Code de confirmation pour √©viter les suppressions accidentelles\n   */\n  async resetDatabase(confirmation) {\n    try {\n      // V√©rifier le code de confirmation\n      if (confirmation !== 'RESET_DATABASE_CONFIRM') {\n        throw new Error('Code de confirmation invalide');\n      }\n      console.log('‚ö†Ô∏è R√âINITIALISATION DE LA BASE DE DONN√âES EN COURS...');\n\n      // Sauvegarder d'abord les donn√©es\n      await this.createFullBackup();\n\n      // Supprimer toutes les collections\n      for (const collectionName of this.collections) {\n        if (collectionName === 'users') {\n          console.log('‚ÑπÔ∏è La collection users ne sera pas supprim√©e pour pr√©server les acc√®s');\n          continue;\n        }\n        const collectionRef = collection(db, collectionName);\n        const snapshot = await getDocs(collectionRef);\n        if (snapshot.empty) {\n          console.log(`‚ÑπÔ∏è La collection ${collectionName} est d√©j√† vide`);\n          continue;\n        }\n        const batch = writeBatch(db);\n        let batchCount = 0;\n        snapshot.docs.forEach(document => {\n          batch.delete(doc(db, collectionName, document.id));\n          batchCount++;\n\n          // Ex√©cuter le batch toutes les 500 op√©rations (limite Firestore)\n          if (batchCount >= 500) {\n            batch.commit();\n            console.log(`‚úÖ Lot de ${batchCount} documents supprim√©s de ${collectionName}`);\n            batchCount = 0;\n          }\n        });\n\n        // Ex√©cuter le dernier batch s'il reste des op√©rations\n        if (batchCount > 0) {\n          await batch.commit();\n          console.log(`‚úÖ Dernier lot de ${batchCount} documents supprim√©s de ${collectionName}`);\n        }\n        console.log(`‚úÖ Collection ${collectionName} r√©initialis√©e`);\n      }\n      console.log('‚úÖ R√©initialisation de la base de donn√©es termin√©e');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la r√©initialisation de la base de donn√©es:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * R√©cup√®re les journaux d'erreurs\n   * Cette fonction est simul√©e car nous n'avons pas de syst√®me de journalisation\n   */\n  async getErrorLogs() {\n    try {\n      console.log('üîÑ R√©cup√©ration des journaux d\\'erreurs...');\n\n      // Simuler des journaux d'erreurs\n      const logs = [{\n        timestamp: new Date().toISOString(),\n        level: 'INFO',\n        message: 'Application d√©marr√©e',\n        source: 'App.tsx'\n      }, {\n        timestamp: new Date(Date.now() - 3600000).toISOString(),\n        level: 'WARNING',\n        message: 'Tentative de connexion √©chou√©e',\n        source: 'AuthContext.tsx'\n      }, {\n        timestamp: new Date(Date.now() - 7200000).toISOString(),\n        level: 'ERROR',\n        message: 'Erreur lors de la r√©cup√©ration des donn√©es',\n        source: 'FirebaseService.ts',\n        stack: 'Error: Failed to fetch data\\n    at FirebaseService.fetchData (/src/services/FirebaseService.ts:42:7)'\n      }];\n      console.log('‚úÖ Journaux d\\'erreurs r√©cup√©r√©s');\n      return logs;\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la r√©cup√©ration des journaux d\\'erreurs:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Exporte les journaux d'erreurs\n   * Cette fonction est simul√©e car nous n'avons pas de syst√®me de journalisation\n   */\n  async exportErrorLogs() {\n    try {\n      console.log('üîÑ Exportation des journaux d\\'erreurs...');\n\n      // R√©cup√©rer les journaux\n      const logs = await this.getErrorLogs();\n\n      // Cr√©er un fichier JSON\n      const blob = new Blob([JSON.stringify(logs, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.setAttribute('href', url);\n      link.setAttribute('download', `error_logs_${new Date().toISOString().split('T')[0]}.json`);\n      link.style.visibility = 'hidden';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      console.log('‚úÖ Exportation des journaux d\\'erreurs termin√©e');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de l\\'exportation des journaux d\\'erreurs:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Ex√©cute un diagnostic complet du syst√®me\n   * Cette fonction est simul√©e\n   */\n  async runFullDiagnostic() {\n    try {\n      console.log('üîÑ Ex√©cution d\\'un diagnostic complet...');\n\n      // Simuler un diagnostic\n      await new Promise(resolve => setTimeout(resolve, 3000));\n      const diagnostic = {\n        timestamp: new Date().toISOString(),\n        system: {\n          status: 'online',\n          uptime: '7 days, 3 hours, 42 minutes',\n          memory: {\n            used: '1.2 GB',\n            total: '2 GB',\n            percentage: 60\n          },\n          cpu: {\n            usage: '23%',\n            temperature: '45¬∞C'\n          }\n        },\n        database: {\n          status: 'connected',\n          latency: '42ms',\n          collections: await this.getCollectionsStats(),\n          lastBackup: 'Jamais'\n        },\n        storage: {\n          used: '2.1 GB',\n          total: '5 GB',\n          percentage: 42\n        },\n        errors: {\n          critical: 0,\n          warning: 2,\n          info: 5\n        }\n      };\n      console.log('‚úÖ Diagnostic complet termin√©');\n      return diagnostic;\n    } catch (error) {\n      console.error('‚ùå Erreur lors de l\\'ex√©cution du diagnostic complet:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Met √† jour les param√®tres de l'application\n   * Cette fonction est simul√©e\n   */\n  async updateAppSettings(settings) {\n    try {\n      console.log('üîÑ Mise √† jour des param√®tres de l\\'application...', settings);\n\n      // Simuler une mise √† jour des param√®tres\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      console.log('‚úÖ Param√®tres de l\\'application mis √† jour');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la mise √† jour des param√®tres de l\\'application:', error);\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["db","collection","getDocs","query","where","Timestamp","doc","writeBatch","SharePointService","JSZip","AdminService","constructor","collections","getCollectionsStats","console","log","stats","collectionName","querySnapshot","size","error","createFullBackup","generateCompleteBackup","createSelectiveBackup","selectedCollections","join","validCollections","filter","col","includes","length","Error","zip","data","exportCollectionToJSON","file","JSON","stringify","content","generateAsync","type","url","URL","createObjectURL","link","document","createElement","setAttribute","Date","toISOString","split","style","visibility","body","appendChild","click","removeChild","cleanupObsoleteData","olderThan","olderThanTimestamp","fromDate","collectionRef","queryRef","snapshot","empty","batch","batchCount","docs","forEach","delete","id","commit","optimizeIndexes","Promise","resolve","setTimeout","resetDatabase","confirmation","getErrorLogs","logs","timestamp","level","message","source","now","stack","exportErrorLogs","blob","Blob","runFullDiagnostic","diagnostic","system","status","uptime","memory","used","total","percentage","cpu","usage","temperature","database","latency","lastBackup","storage","errors","critical","warning","info","updateAppSettings","settings"],"sources":["C:/Users/LS_110/Documents/GitHub/inovie-SCAN-web-main/src/services/AdminService.ts"],"sourcesContent":["import { db } from '../config/firebase';\nimport { collection, getDocs, query, where, orderBy, limit, Timestamp, addDoc, doc, setDoc, deleteDoc, writeBatch, deleteField } from 'firebase/firestore';\nimport SharePointService from './SharePointService';\nimport JSZip from 'jszip';\n\n/**\n * Service pour g√©rer les fonctionnalit√©s d'administration\n */\nexport class AdminService {\n  // Collections Firebase\n  private collections = ['passages', 'sites', 'tournees', 'vehicules', 'users'];\n  \n  /**\n   * R√©cup√®re les statistiques des collections\n   * @returns Statistiques des collections\n   */\n  async getCollectionsStats(): Promise<Record<string, number>> {\n    try {\n      console.log('üîÑ R√©cup√©ration des statistiques des collections...');\n      \n      const stats: Record<string, number> = {};\n      \n      for (const collectionName of this.collections) {\n        const querySnapshot = await getDocs(collection(db, collectionName));\n        stats[collectionName] = querySnapshot.size;\n      }\n      \n      console.log('‚úÖ Statistiques r√©cup√©r√©es:', stats);\n      return stats;\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la r√©cup√©ration des statistiques:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Cr√©e une sauvegarde compl√®te de la base de donn√©es\n   * @returns Fichier ZIP contenant toutes les collections\n   */\n  async createFullBackup(): Promise<void> {\n    try {\n      console.log('üîÑ Cr√©ation d\\'une sauvegarde compl√®te...');\n      \n      // Utiliser le service SharePoint pour g√©n√©rer la sauvegarde\n      await SharePointService.generateCompleteBackup();\n      \n      console.log('‚úÖ Sauvegarde compl√®te cr√©√©e avec succ√®s');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la cr√©ation de la sauvegarde compl√®te:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Cr√©e une sauvegarde s√©lective de certaines collections\n   * @param selectedCollections Collections √† sauvegarder\n   */\n  async createSelectiveBackup(selectedCollections: string[]): Promise<void> {\n    try {\n      console.log(`üîÑ Cr√©ation d'une sauvegarde s√©lective pour les collections: ${selectedCollections.join(', ')}...`);\n      \n      // V√©rifier que les collections s√©lectionn√©es sont valides\n      const validCollections = selectedCollections.filter(col => this.collections.includes(col));\n      \n      if (validCollections.length === 0) {\n        throw new Error('Aucune collection valide s√©lectionn√©e pour la sauvegarde');\n      }\n      \n      // Cr√©er un objet ZIP\n      const zip = new JSZip();\n      \n      // Ajouter chaque collection s√©lectionn√©e au ZIP\n      for (const collectionName of validCollections) {\n        const data = await SharePointService.exportCollectionToJSON(collectionName);\n        \n        if (data && data.length > 0) {\n          zip.file(`${collectionName}.json`, JSON.stringify(data, null, 2));\n        }\n      }\n      \n      // G√©n√©rer le fichier ZIP\n      const content = await zip.generateAsync({ type: 'blob' });\n      \n      // T√©l√©charger le fichier\n      const url = URL.createObjectURL(content);\n      const link = document.createElement('a');\n      \n      link.setAttribute('href', url);\n      link.setAttribute('download', `selective_backup_${new Date().toISOString().split('T')[0]}.zip`);\n      link.style.visibility = 'hidden';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      console.log('‚úÖ Sauvegarde s√©lective cr√©√©e avec succ√®s');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la cr√©ation de la sauvegarde s√©lective:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Nettoie les donn√©es obsol√®tes d'une collection\n   * @param collectionName Nom de la collection √† nettoyer\n   * @param olderThan Date limite (les documents plus anciens seront supprim√©s)\n   * @returns Nombre de documents supprim√©s\n   */\n  async cleanupObsoleteData(collectionName: string, olderThan: Date): Promise<number> {\n    try {\n      console.log(`üîÑ Nettoyage des donn√©es obsol√®tes de la collection ${collectionName}...`);\n      \n      // V√©rifier que la collection est valide\n      if (!this.collections.includes(collectionName)) {\n        throw new Error(`La collection ${collectionName} n'est pas valide`);\n      }\n      \n      // Convertir la date en Timestamp\n      const olderThanTimestamp = Timestamp.fromDate(olderThan);\n      \n      // R√©cup√©rer les documents √† supprimer\n      const collectionRef = collection(db, collectionName);\n      let queryRef;\n      \n      // Adapter la requ√™te en fonction de la collection\n      if (collectionName === 'passages') {\n        queryRef = query(collectionRef, where('date', '<', olderThanTimestamp));\n      } else if (collectionName === 'users') {\n        queryRef = query(collectionRef, where('lastLogin', '<', olderThanTimestamp));\n      } else {\n        queryRef = query(collectionRef, where('updatedAt', '<', olderThanTimestamp));\n      }\n      \n      const snapshot = await getDocs(queryRef);\n      \n      if (snapshot.empty) {\n        console.log(`‚ÑπÔ∏è Aucune donn√©e obsol√®te trouv√©e dans la collection ${collectionName}`);\n        return 0;\n      }\n      \n      // Supprimer les documents\n      const batch = writeBatch(db);\n      let batchCount = 0;\n      \n      snapshot.docs.forEach(document => {\n        batch.delete(doc(db, collectionName, document.id));\n        batchCount++;\n        \n        // Ex√©cuter le batch toutes les 500 op√©rations (limite Firestore)\n        if (batchCount >= 500) {\n          batch.commit();\n          console.log(`‚úÖ Lot de ${batchCount} documents supprim√©s`);\n          batchCount = 0;\n        }\n      });\n      \n      // Ex√©cuter le dernier batch s'il reste des op√©rations\n      if (batchCount > 0) {\n        await batch.commit();\n        console.log(`‚úÖ Dernier lot de ${batchCount} documents supprim√©s`);\n      }\n      \n      console.log(`‚úÖ Nettoyage termin√©: ${snapshot.size} documents supprim√©s de la collection ${collectionName}`);\n      return snapshot.size;\n    } catch (error) {\n      console.error(`‚ùå Erreur lors du nettoyage des donn√©es obsol√®tes:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Optimise les index de la base de donn√©es\n   * Cette fonction est simul√©e car Firestore g√®re automatiquement ses index\n   */\n  async optimizeIndexes(): Promise<void> {\n    try {\n      console.log('üîÑ Optimisation des index...');\n      \n      // Simuler une op√©ration d'optimisation\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      console.log('‚úÖ Optimisation des index termin√©e');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de l\\'optimisation des index:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * R√©initialise la base de donn√©es (DANGER)\n   * @param confirmation Code de confirmation pour √©viter les suppressions accidentelles\n   */\n  async resetDatabase(confirmation: string): Promise<void> {\n    try {\n      // V√©rifier le code de confirmation\n      if (confirmation !== 'RESET_DATABASE_CONFIRM') {\n        throw new Error('Code de confirmation invalide');\n      }\n      \n      console.log('‚ö†Ô∏è R√âINITIALISATION DE LA BASE DE DONN√âES EN COURS...');\n      \n      // Sauvegarder d'abord les donn√©es\n      await this.createFullBackup();\n      \n      // Supprimer toutes les collections\n      for (const collectionName of this.collections) {\n        if (collectionName === 'users') {\n          console.log('‚ÑπÔ∏è La collection users ne sera pas supprim√©e pour pr√©server les acc√®s');\n          continue;\n        }\n        \n        const collectionRef = collection(db, collectionName);\n        const snapshot = await getDocs(collectionRef);\n        \n        if (snapshot.empty) {\n          console.log(`‚ÑπÔ∏è La collection ${collectionName} est d√©j√† vide`);\n          continue;\n        }\n        \n        const batch = writeBatch(db);\n        let batchCount = 0;\n        \n        snapshot.docs.forEach(document => {\n          batch.delete(doc(db, collectionName, document.id));\n          batchCount++;\n          \n          // Ex√©cuter le batch toutes les 500 op√©rations (limite Firestore)\n          if (batchCount >= 500) {\n            batch.commit();\n            console.log(`‚úÖ Lot de ${batchCount} documents supprim√©s de ${collectionName}`);\n            batchCount = 0;\n          }\n        });\n        \n        // Ex√©cuter le dernier batch s'il reste des op√©rations\n        if (batchCount > 0) {\n          await batch.commit();\n          console.log(`‚úÖ Dernier lot de ${batchCount} documents supprim√©s de ${collectionName}`);\n        }\n        \n        console.log(`‚úÖ Collection ${collectionName} r√©initialis√©e`);\n      }\n      \n      console.log('‚úÖ R√©initialisation de la base de donn√©es termin√©e');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la r√©initialisation de la base de donn√©es:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * R√©cup√®re les journaux d'erreurs\n   * Cette fonction est simul√©e car nous n'avons pas de syst√®me de journalisation\n   */\n  async getErrorLogs(): Promise<any[]> {\n    try {\n      console.log('üîÑ R√©cup√©ration des journaux d\\'erreurs...');\n      \n      // Simuler des journaux d'erreurs\n      const logs = [\n        {\n          timestamp: new Date().toISOString(),\n          level: 'INFO',\n          message: 'Application d√©marr√©e',\n          source: 'App.tsx'\n        },\n        {\n          timestamp: new Date(Date.now() - 3600000).toISOString(),\n          level: 'WARNING',\n          message: 'Tentative de connexion √©chou√©e',\n          source: 'AuthContext.tsx'\n        },\n        {\n          timestamp: new Date(Date.now() - 7200000).toISOString(),\n          level: 'ERROR',\n          message: 'Erreur lors de la r√©cup√©ration des donn√©es',\n          source: 'FirebaseService.ts',\n          stack: 'Error: Failed to fetch data\\n    at FirebaseService.fetchData (/src/services/FirebaseService.ts:42:7)'\n        }\n      ];\n      \n      console.log('‚úÖ Journaux d\\'erreurs r√©cup√©r√©s');\n      return logs;\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la r√©cup√©ration des journaux d\\'erreurs:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Exporte les journaux d'erreurs\n   * Cette fonction est simul√©e car nous n'avons pas de syst√®me de journalisation\n   */\n  async exportErrorLogs(): Promise<void> {\n    try {\n      console.log('üîÑ Exportation des journaux d\\'erreurs...');\n      \n      // R√©cup√©rer les journaux\n      const logs = await this.getErrorLogs();\n      \n      // Cr√©er un fichier JSON\n      const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      \n      link.setAttribute('href', url);\n      link.setAttribute('download', `error_logs_${new Date().toISOString().split('T')[0]}.json`);\n      link.style.visibility = 'hidden';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      console.log('‚úÖ Exportation des journaux d\\'erreurs termin√©e');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de l\\'exportation des journaux d\\'erreurs:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Ex√©cute un diagnostic complet du syst√®me\n   * Cette fonction est simul√©e\n   */\n  async runFullDiagnostic(): Promise<any> {\n    try {\n      console.log('üîÑ Ex√©cution d\\'un diagnostic complet...');\n      \n      // Simuler un diagnostic\n      await new Promise(resolve => setTimeout(resolve, 3000));\n      \n      const diagnostic = {\n        timestamp: new Date().toISOString(),\n        system: {\n          status: 'online',\n          uptime: '7 days, 3 hours, 42 minutes',\n          memory: {\n            used: '1.2 GB',\n            total: '2 GB',\n            percentage: 60\n          },\n          cpu: {\n            usage: '23%',\n            temperature: '45¬∞C'\n          }\n        },\n        database: {\n          status: 'connected',\n          latency: '42ms',\n          collections: await this.getCollectionsStats(),\n          lastBackup: 'Jamais'\n        },\n        storage: {\n          used: '2.1 GB',\n          total: '5 GB',\n          percentage: 42\n        },\n        errors: {\n          critical: 0,\n          warning: 2,\n          info: 5\n        }\n      };\n      \n      console.log('‚úÖ Diagnostic complet termin√©');\n      return diagnostic;\n    } catch (error) {\n      console.error('‚ùå Erreur lors de l\\'ex√©cution du diagnostic complet:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Met √† jour les param√®tres de l'application\n   * Cette fonction est simul√©e\n   */\n  async updateAppSettings(settings: any): Promise<void> {\n    try {\n      console.log('üîÑ Mise √† jour des param√®tres de l\\'application...', settings);\n      \n      // Simuler une mise √† jour des param√®tres\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      console.log('‚úÖ Param√®tres de l\\'application mis √† jour');\n    } catch (error) {\n      console.error('‚ùå Erreur lors de la mise √† jour des param√®tres de l\\'application:', error);\n      throw error;\n    }\n  }\n} \r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}