import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { db } from '../firebase';
import { collection, query, where, getDocs, onSnapshot, Timestamp, updateDoc, doc, getDoc } from 'firebase/firestore';
import { MapContainer, TileLayer, Marker, Popup, LayerGroup, LayersControl, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { geocodeAddress } from '../utils/geocoding';
import './MapView.css';
import 'leaflet.markercluster';
import './MarkerCluster.css';
import './MarkerCluster.Default.css';
import { MarkerPreference } from '../types';
// Renommer les imports pour éviter les conflits avec les interfaces locales
// import { Site, Tournee, MarkerPreference } from '../types';

// Fix pour les icônes Leaflet
import markerIcon2x from 'leaflet/dist/images/marker-icon-2x.png';
import markerIcon from 'leaflet/dist/images/marker-icon.png';
import markerShadow from 'leaflet/dist/images/marker-shadow.png';

// Correction pour les icônes Leaflet
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

// Définir des icônes spécifiques
const siteIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const departIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const arrivalIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

// Définir des icônes spécifiques pour chaque type de site
const laboratoireIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-laboratoire'
});

const cliniqueIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-clinique'
});

const plateauIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-plateau'
});

const collecteIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-collecte'
});

const etablissementIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-etablissement'
});

const ehpadIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-ehpad'
});

const veterinaireIcon = L.icon({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
  className: 'site-icon site-icon-veterinaire'
});

// Types de sites disponibles
const SITE_TYPES = [
  'Laboratoire',
  'Clinique',
  'Plateau technique',
  'Point de collecte',
  'Etablissement de santé',
  'Ehpad',
  'Vétérinaire'
];

// Pôles disponibles
const POLES = [
  'Nord',
  'Sud',
  'Est',
  'Ouest',
  'Centre'
];

// Fonction pour normaliser les types de sites
const normalizeType = (type: string | undefined): string => {
  if (!type) return '';
  
  const normalized = type.toLowerCase().trim();
  
  // Normaliser les types courants
  if (normalized.includes('labo')) return 'laboratoire';
  if (normalized.includes('plateau')) return 'plateau technique';
  if (normalized.includes('clinique')) return 'clinique';
  if (normalized.includes('collect')) return 'point de collecte';
  if (normalized.includes('etablissement') || normalized.includes('établissement')) return 'etablissement de santé';
  if (normalized.includes('ehpad')) return 'ehpad';
  if (normalized.includes('veterinaire') || normalized.includes('vétérinaire')) return 'veterinaire';
  
  return normalized;
};

// Fonction pour obtenir l'icône par défaut en fonction du type de site
const getDefaultIconForSiteType = (type: string | undefined): L.Icon => {
  if (!type) return siteIcon;
  
  // Normaliser le type pour la comparaison
  const normalizedType = normalizeType(type);
  
  // Retourner l'icône correspondante
  if (normalizedType === 'laboratoire') {
    return laboratoireIcon;
  } else if (normalizedType === 'clinique') {
    return cliniqueIcon;
  } else if (normalizedType === 'plateau technique') {
    return plateauIcon;
  } else if (normalizedType === 'point de collecte') {
    return collecteIcon;
  } else if (normalizedType === 'etablissement de santé') {
    return etablissementIcon;
  } else if (normalizedType === 'ehpad') {
    return ehpadIcon;
  } else if (normalizedType === 'veterinaire') {
    return veterinaireIcon;
  }
  
  // Par défaut, retourner l'icône générique
  return siteIcon;
};

interface CourierLocation {
  id: string;
  nom: string;
  tourneeId: string;
  tourneeName: string;
  siteId: string;
  siteName: string;
  latitude: number;
  longitude: number;
  lastScan: Timestamp;
  isArrival: boolean; // Indique si le coursier est à l'arrivée ou au départ
}

interface Site {
  id: string;
  nom: string;
  adresse: string;
  ville?: string;
  codePostal?: string;
  codeBarres: string;
  latitude?: number;
  longitude?: number;
  type?: string;
  pole?: string;
}

interface Tournee {
  id: string;
  nom: string;
}

// Composant pour ajouter le contrôle plein écran personnalisé
const FullscreenControl: React.FC = () => {
  const map = useMap();
  const [isFullscreen, setIsFullscreen] = useState(false);
  
  useEffect(() => {
    // Créer un contrôle personnalisé
    const FullscreenControl = L.Control.extend({
      options: {
        position: 'topleft'
      },
      
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        const button = L.DomUtil.create('a', 'leaflet-control-fullscreen', container);
        
        button.innerHTML = '⤢';
        button.href = '#';
        button.title = 'Afficher en plein écran';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-label', 'Afficher en plein écran');
        
        L.DomEvent.on(button, 'click', function(e) {
          L.DomEvent.preventDefault(e);
          
          const mapContainer = map.getContainer();
          
          if (!document.fullscreenElement) {
            if (mapContainer.requestFullscreen) {
              mapContainer.requestFullscreen();
              button.innerHTML = '⤓';
              button.title = 'Quitter le plein écran';
              setIsFullscreen(true);
            }
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
              button.innerHTML = '⤢';
              button.title = 'Afficher en plein écran';
              setIsFullscreen(false);
            }
          }
        });
        
        // Écouter les changements d'état du plein écran
        const handleFullscreenChange = () => {
          if (!document.fullscreenElement && isFullscreen) {
            button.innerHTML = '⤢';
            button.title = 'Afficher en plein écran';
            setIsFullscreen(false);
          }
        };
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        
        return container;
      }
    });
    
    // Ajouter le contrôle à la carte
    const fullscreenControl = new FullscreenControl();
    map.addControl(fullscreenControl);
    
    return () => {
      map.removeControl(fullscreenControl);
      document.removeEventListener('fullscreenchange', () => {});
    };
  }, [map, isFullscreen]);
  
  return null;
};

// Composant pour afficher tous les sites
const AllSitesLayer: React.FC<{
  sites: Site[];
  icon: L.Icon;
  getIconForSiteType: (type: string) => L.Icon;
  showLabels: boolean;
  showGeneratedCoordinates: boolean;
}> = ({ sites, icon, getIconForSiteType, showLabels, showGeneratedCoordinates }) => {
  const map = useMap();
  const layerRef = useRef<L.LayerGroup | null>(null);
  const [isVisible, setIsVisible] = useState(true);
  
  useEffect(() => {
    // Créer un nouveau LayerGroup si nécessaire
    if (!layerRef.current) {
      layerRef.current = L.layerGroup();
      
      // Ajouter le LayerGroup à la carte si la couche est visible
      if (isVisible) {
        layerRef.current.addTo(map);
      }
    } else {
      // Sinon, vider le LayerGroup existant
      layerRef.current.clearLayers();
      
      // Ajouter ou retirer le LayerGroup de la carte selon la visibilité
      if (isVisible && !map.hasLayer(layerRef.current)) {
        map.addLayer(layerRef.current);
      } else if (!isVisible && map.hasLayer(layerRef.current)) {
        map.removeLayer(layerRef.current);
      }
    }
    
    // Ajouter les marqueurs au LayerGroup seulement si la couche est visible
    if (isVisible) {
      sites.forEach(site => {
        // Vérifier si les coordonnées sont générées
        const isGeneratedCoords = site.hasOwnProperty('isGeneratedCoordinates') && 
                                (site as any).isGeneratedCoordinates === true;
        
        if (!showGeneratedCoordinates && isGeneratedCoords) {
          return;
        }
        
        if (site.latitude && site.longitude) {
          const siteIcon = getIconForSiteType(site.type || '');
          const marker = L.marker([site.latitude, site.longitude], { icon: siteIcon })
            .bindPopup(`
              <div class="site-popup">
                <h3>${site.nom}</h3>
                <p><strong>Type:</strong> ${site.type}</p>
                <p><strong>Adresse:</strong> ${site.adresse}</p>
                <p><strong>Pôle:</strong> ${site.pole || 'Non défini'}</p>
                ${isGeneratedCoords ? '<p class="warning">Coordonnées générées automatiquement</p>' : ''}
              </div>
            `);
          
          if (showLabels) {
            marker.bindTooltip(site.nom, { permanent: true, direction: 'top', className: 'site-label' });
          }
          
          layerRef.current?.addLayer(marker);
        }
      });
    }
    
    // Nettoyer le LayerGroup lors du démontage du composant
    return () => {
      if (layerRef.current) {
        if (map.hasLayer(layerRef.current)) {
          map.removeLayer(layerRef.current);
        }
        layerRef.current = null;
      }
    };
  }, [sites, icon, getIconForSiteType, showLabels, showGeneratedCoordinates, map, isVisible]);
  
  // Gérer l'affichage/masquage de la couche en fonction du contrôle des couches
  useEffect(() => {
    const handleLayerControlChange = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === 'Tous les sites') {
            // Mettre à jour l'état de visibilité en fonction de la case à cocher
            setIsVisible((checkbox as HTMLInputElement).checked);
            
            // Ajouter un écouteur d'événements pour les changements futurs
            (checkbox as HTMLInputElement).addEventListener('change', (e) => {
              const isChecked = (e.target as HTMLInputElement).checked;
              setIsVisible(isChecked);
            });
          }
        });
      }
    };
    
    // Attendre que le contrôle des couches soit ajouté à la carte
    const checkLayersControl = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        handleLayerControlChange();
      } else {
        // Si le contrôle n'est pas encore disponible, réessayer plus tard
        setTimeout(checkLayersControl, 100);
      }
    };
    
    checkLayersControl();
    
    // Nettoyer les écouteurs d'événements lors du démontage du composant
    return () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === 'Tous les sites') {
            (checkbox as HTMLInputElement).removeEventListener('change', () => {});
          }
        });
      }
    };
  }, [map]);
  
  return null;
};

// Composant pour afficher les sites par type
const SiteTypeLayer: React.FC<{
  sites: Site[];
  icon: L.Icon;
  type: string;
  getIconForSiteType: (type: string) => L.Icon;
  showLabels: boolean;
  showGeneratedCoordinates: boolean;
}> = ({ sites, icon, type, getIconForSiteType, showLabels, showGeneratedCoordinates }) => {
  const map = useMap();
  const layerRef = useRef<L.LayerGroup | null>(null);
  const [isVisible, setIsVisible] = useState(true);
  
  useEffect(() => {
    // Créer un nouveau LayerGroup si nécessaire
    if (!layerRef.current) {
      layerRef.current = L.layerGroup();
      
      // Ajouter le LayerGroup à la carte si la couche est visible
      if (isVisible) {
        layerRef.current.addTo(map);
      }
    } else {
      // Sinon, vider le LayerGroup existant
      layerRef.current.clearLayers();
      
      // Ajouter ou retirer le LayerGroup de la carte selon la visibilité
      if (isVisible && !map.hasLayer(layerRef.current)) {
        map.addLayer(layerRef.current);
      } else if (!isVisible && map.hasLayer(layerRef.current)) {
        map.removeLayer(layerRef.current);
      }
    }
    
    // Ajouter les marqueurs au LayerGroup seulement si la couche est visible
    if (isVisible) {
      // Filtrer les sites par type et ajouter les marqueurs au LayerGroup
      const filteredSites = sites.filter(site => normalizeType(site.type || '') === normalizeType(type));
      
      filteredSites.forEach(site => {
        // Vérifier si les coordonnées sont générées
        const isGeneratedCoords = site.hasOwnProperty('isGeneratedCoordinates') && 
                                (site as any).isGeneratedCoordinates === true;
        
        if (!showGeneratedCoordinates && isGeneratedCoords) {
          return;
        }
        
        if (site.latitude && site.longitude) {
          const siteIcon = getIconForSiteType(site.type || '');
          const marker = L.marker([site.latitude, site.longitude], { icon: siteIcon })
            .bindPopup(`
              <div class="site-popup">
                <h3>${site.nom}</h3>
                <p><strong>Type:</strong> ${site.type}</p>
                <p><strong>Adresse:</strong> ${site.adresse}</p>
                <p><strong>Pôle:</strong> ${site.pole || 'Non défini'}</p>
                ${isGeneratedCoords ? '<p class="warning">Coordonnées générées automatiquement</p>' : ''}
              </div>
            `);
          
          if (showLabels) {
            marker.bindTooltip(site.nom, { permanent: true, direction: 'top', className: 'site-label' });
          }
          
          layerRef.current?.addLayer(marker);
        }
      });
    }
    
    // Nettoyer le LayerGroup lors du démontage du composant
    return () => {
      if (layerRef.current) {
        if (map.hasLayer(layerRef.current)) {
          map.removeLayer(layerRef.current);
        }
        layerRef.current = null;
      }
    };
  }, [sites, icon, type, getIconForSiteType, showLabels, showGeneratedCoordinates, map, isVisible]);
  
  // Gérer l'affichage/masquage de la couche en fonction du contrôle des couches
  useEffect(() => {
    const handleLayerControlChange = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === type) {
            // Mettre à jour l'état de visibilité en fonction de la case à cocher
            setIsVisible((checkbox as HTMLInputElement).checked);
            
            // Ajouter un écouteur d'événements pour les changements futurs
            (checkbox as HTMLInputElement).addEventListener('change', (e) => {
              const isChecked = (e.target as HTMLInputElement).checked;
              setIsVisible(isChecked);
            });
          }
        });
      }
    };
    
    // Attendre que le contrôle des couches soit ajouté à la carte
    const checkLayersControl = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        handleLayerControlChange();
      } else {
        // Si le contrôle n'est pas encore disponible, réessayer plus tard
        setTimeout(checkLayersControl, 100);
      }
    };
    
    checkLayersControl();
    
    // Nettoyer les écouteurs d'événements lors du démontage du composant
    return () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === type) {
            (checkbox as HTMLInputElement).removeEventListener('change', () => {});
          }
        });
      }
    };
  }, [map, type]);
  
  return null;
};

// Composant pour afficher les sites par pôle
const PoleLayer: React.FC<{
  sites: Site[];
  icon: L.Icon;
  pole: string;
  getIconForSiteType: (type: string) => L.Icon;
  showLabels: boolean;
  showGeneratedCoordinates: boolean;
}> = ({ sites, icon, pole, getIconForSiteType, showLabels, showGeneratedCoordinates }) => {
  const map = useMap();
  const layerRef = useRef<L.LayerGroup | null>(null);
  const [isVisible, setIsVisible] = useState(true);
  
  useEffect(() => {
    // Créer un nouveau LayerGroup si nécessaire
    if (!layerRef.current) {
      layerRef.current = L.layerGroup();
      
      // Ajouter le LayerGroup à la carte si la couche est visible
      if (isVisible) {
        layerRef.current.addTo(map);
      }
    } else {
      // Sinon, vider le LayerGroup existant
      layerRef.current.clearLayers();
      
      // Ajouter ou retirer le LayerGroup de la carte selon la visibilité
      if (isVisible && !map.hasLayer(layerRef.current)) {
        map.addLayer(layerRef.current);
      } else if (!isVisible && map.hasLayer(layerRef.current)) {
        map.removeLayer(layerRef.current);
      }
    }
    
    // Ajouter les marqueurs au LayerGroup seulement si la couche est visible
    if (isVisible) {
      // Filtrer les sites par pôle et ajouter les marqueurs au LayerGroup
      const filteredSites = sites.filter(site => site.pole === pole);
      
      filteredSites.forEach(site => {
        // Vérifier si les coordonnées sont générées
        const isGeneratedCoords = site.hasOwnProperty('isGeneratedCoordinates') && 
                                (site as any).isGeneratedCoordinates === true;
        
        if (!showGeneratedCoordinates && isGeneratedCoords) {
          return;
        }
        
        if (site.latitude && site.longitude) {
          const siteIcon = getIconForSiteType(site.type || '');
          const marker = L.marker([site.latitude, site.longitude], { icon: siteIcon })
            .bindPopup(`
              <div class="site-popup">
                <h3>${site.nom}</h3>
                <p><strong>Type:</strong> ${site.type}</p>
                <p><strong>Adresse:</strong> ${site.adresse}</p>
                <p><strong>Pôle:</strong> ${site.pole || 'Non défini'}</p>
                ${isGeneratedCoords ? '<p class="warning">Coordonnées générées automatiquement</p>' : ''}
              </div>
            `);
          
          if (showLabels) {
            marker.bindTooltip(site.nom, { permanent: true, direction: 'top', className: 'site-label' });
          }
          
          layerRef.current?.addLayer(marker);
        }
      });
    }
    
    // Nettoyer le LayerGroup lors du démontage du composant
    return () => {
      if (layerRef.current) {
        if (map.hasLayer(layerRef.current)) {
          map.removeLayer(layerRef.current);
        }
        layerRef.current = null;
      }
    };
  }, [sites, icon, pole, getIconForSiteType, showLabels, showGeneratedCoordinates, map, isVisible]);
  
  // Gérer l'affichage/masquage de la couche en fonction du contrôle des couches
  useEffect(() => {
    const handleLayerControlChange = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === `Pôle ${pole}`) {
            // Mettre à jour l'état de visibilité en fonction de la case à cocher
            setIsVisible((checkbox as HTMLInputElement).checked);
            
            // Ajouter un écouteur d'événements pour les changements futurs
            (checkbox as HTMLInputElement).addEventListener('change', (e) => {
              const isChecked = (e.target as HTMLInputElement).checked;
              setIsVisible(isChecked);
            });
          }
        });
      }
    };
    
    // Attendre que le contrôle des couches soit ajouté à la carte
    const checkLayersControl = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        handleLayerControlChange();
      } else {
        // Si le contrôle n'est pas encore disponible, réessayer plus tard
        setTimeout(checkLayersControl, 100);
      }
    };
    
    checkLayersControl();
    
    // Nettoyer les écouteurs d'événements lors du démontage du composant
    return () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === `Pôle ${pole}`) {
            (checkbox as HTMLInputElement).removeEventListener('change', () => {});
          }
        });
      }
    };
  }, [map, pole]);
  
  return null;
};

// Composant pour afficher les coursiers
const CouriersLayer: React.FC<{
  courierLocations: CourierLocation[];
  departIcon: L.Icon;
  arrivalIcon: L.Icon;
  formatDate: (date: any) => string;
}> = ({ courierLocations, departIcon, arrivalIcon, formatDate }) => {
  const map = useMap();
  const layerRef = useRef<L.LayerGroup | null>(null);
  const [isVisible, setIsVisible] = useState(true);
  
  useEffect(() => {
    // Créer un nouveau LayerGroup si nécessaire
    if (!layerRef.current) {
      layerRef.current = L.layerGroup();
      
      // Ajouter le LayerGroup à la carte si la couche est visible
      if (isVisible) {
        layerRef.current.addTo(map);
      }
    } else {
      // Sinon, vider le LayerGroup existant
      layerRef.current.clearLayers();
      
      // Ajouter ou retirer le LayerGroup de la carte selon la visibilité
      if (isVisible && !map.hasLayer(layerRef.current)) {
        map.addLayer(layerRef.current);
      } else if (!isVisible && map.hasLayer(layerRef.current)) {
        map.removeLayer(layerRef.current);
      }
    }
    
    // Ajouter les marqueurs des coursiers au LayerGroup seulement si la couche est visible
    if (isVisible) {
      courierLocations.forEach(courier => {
        const icon = courier.isArrival ? arrivalIcon : departIcon;
        const marker = L.marker([courier.latitude, courier.longitude], { icon })
          .bindPopup(`
            <div class="courier-popup">
              <h3>${courier.nom}</h3>
              <p><strong>Tournée:</strong> ${courier.tourneeName}</p>
              <p><strong>Dernier scan:</strong> ${formatDate(courier.lastScan)}</p>
              <p><strong>Site:</strong> ${courier.siteName}</p>
              <p><strong>Statut:</strong> ${courier.isArrival ? 'Arrivée' : 'Départ'}</p>
            </div>
          `);
        
        layerRef.current?.addLayer(marker);
      });
    }
    
    // Nettoyer le LayerGroup lors du démontage du composant
    return () => {
      if (layerRef.current) {
        if (map.hasLayer(layerRef.current)) {
          map.removeLayer(layerRef.current);
        }
        layerRef.current = null;
      }
    };
  }, [courierLocations, departIcon, arrivalIcon, formatDate, map, isVisible]);
  
  // Gérer l'affichage/masquage de la couche en fonction du contrôle des couches
  useEffect(() => {
    const handleLayerControlChange = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === 'Coursiers') {
            // Mettre à jour l'état de visibilité en fonction de la case à cocher
            setIsVisible((checkbox as HTMLInputElement).checked);
            
            // Ajouter un écouteur d'événements pour les changements futurs
            (checkbox as HTMLInputElement).addEventListener('change', (e) => {
              const isChecked = (e.target as HTMLInputElement).checked;
              setIsVisible(isChecked);
            });
          }
        });
      }
    };
    
    // Attendre que le contrôle des couches soit ajouté à la carte
    const checkLayersControl = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        handleLayerControlChange();
      } else {
        // Si le contrôle n'est pas encore disponible, réessayer plus tard
        setTimeout(checkLayersControl, 100);
      }
    };
    
    checkLayersControl();
    
    // Nettoyer les écouteurs d'événements lors du démontage du composant
    return () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          if ((checkbox as HTMLInputElement).nextSibling?.textContent?.trim() === 'Coursiers') {
            (checkbox as HTMLInputElement).removeEventListener('change', () => {});
          }
        });
      }
    };
  }, [map]);
  
  return null;
};

// Composant pour gérer les animations des marqueurs
const AnimatedMarker: React.FC<{
  position: [number, number];
  icon: L.Icon;
  popup: React.ReactNode;
  markerId: string;
}> = ({ position, icon, popup, markerId }) => {
  const markerRef = useRef<L.Marker | null>(null);
  const map = useMap();

  useEffect(() => {
    if (markerRef.current) {
      const marker = markerRef.current;
      const currentPos = marker.getLatLng();
      const targetPos = L.latLng(position[0], position[1]);

      // Animation fluide si le marqueur existe déjà
      if (currentPos && !currentPos.equals(targetPos)) {
        marker.slideTo(targetPos, {
          duration: 1000,
          keepAtCenter: false
        });
      }
    }
  }, [position]);

  return (
    <Marker
      position={position}
      icon={icon}
      ref={markerRef}
    >
      {popup}
    </Marker>
  );
};

// Coordonnées du centre de la France
const franceCenter: [number, number] = [46.603354, 1.888334];

// Fonction pour générer des coordonnées pour un site sans coordonnées
const generateCoordinates = (site: Site, index: number): [number, number] => {
  // Coordonnées de base (centre de la France)
  const baseLatitude = 46.603354;
  const baseLongitude = 1.888334;
  
  // Si le site a un code postal, utiliser les deux premiers chiffres pour générer des coordonnées
  if (site.codePostal && site.codePostal.length >= 2) {
    const departement = parseInt(site.codePostal.substring(0, 2), 10);
    
    // Carte approximative des départements français (latitude et longitude)
    // Nous utilisons le numéro de département pour générer des coordonnées approximatives
    const latOffset = ((departement % 10) - 5) * 0.5; // -2.5 à +2.5 degrés
    const lonOffset = ((Math.floor(departement / 10) % 10) - 5) * 0.5; // -2.5 à +2.5 degrés
    
    // Ajouter un petit décalage pour chaque site dans le même département
    const siteOffset = index * 0.01;
    
    return [
      baseLatitude + latOffset + siteOffset,
      baseLongitude + lonOffset + siteOffset
    ];
  }
  
  // Si le site a une ville mais pas de code postal, utiliser la première lettre de la ville
  if (site.ville) {
    const firstLetter = site.ville.charAt(0).toUpperCase();
    const letterCode = firstLetter.charCodeAt(0) - 65; // A=0, B=1, etc.
    
    // Utiliser le code de la lettre pour générer des coordonnées
    const latOffset = ((letterCode % 5) - 2) * 0.5; // -1 à +1 degrés
    const lonOffset = ((Math.floor(letterCode / 5) % 5) - 2) * 0.5; // -1 à +1 degrés
    
    // Ajouter un petit décalage pour chaque site dans la même ville
    const siteOffset = index * 0.01;
    
    return [
      baseLatitude + latOffset + siteOffset,
      baseLongitude + lonOffset + siteOffset
    ];
  }
  
  // Si le site n'a ni code postal ni ville, utiliser un décalage basé sur l'index
  return [
    baseLatitude + (index * 0.01),
    baseLongitude + (index * 0.01)
  ];
};

// Composant pour la légende des sites
const SiteLegend: React.FC = () => {
  const map = useMap();
  const [markerPreferences, setMarkerPreferences] = useState<MarkerPreference[]>([]);

  useEffect(() => {
    // Récupérer les préférences de marqueurs
    const fetchPreferences = async () => {
      try {
        const preferencesRef = collection(db, 'markerPreferences');
        const snapshot = await getDocs(preferencesRef);
        
        if (!snapshot.empty) {
          const preferencesData = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          })) as MarkerPreference[];
          
          setMarkerPreferences(preferencesData);
          console.log(`Légende: ${preferencesData.length} préférences de marqueurs chargées`);
        }
      } catch (error) {
        console.error('Erreur lors de la récupération des préférences de marqueurs pour la légende:', error);
      }
    };
    
    fetchPreferences();
    
    // Créer un contrôle personnalisé pour la légende
    const LegendControl = L.Control.extend({
      options: {
        position: 'bottomright'
      },
      
      onAdd: function(map: L.Map): HTMLElement {
        const div = L.DomUtil.create('div', 'info legend site-legend');
        
        // Fonction pour mettre à jour le contenu de la légende
        const updateLegendContent = () => {
          // Utiliser les préférences de marqueurs si disponibles
          const legendItems = markerPreferences.length > 0 
            ? markerPreferences.map(pref => `
                <div class="site-legend-item">
                  <div class="site-legend-color" style="background-color: ${pref.color};"></div>
                  <div class="site-legend-label">${pref.name}</div>
                </div>
              `).join('')
            : `
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-laboratoire"></div>
                <div class="site-legend-label">Laboratoire</div>
              </div>
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-clinique"></div>
                <div class="site-legend-label">Clinique</div>
              </div>
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-plateau"></div>
                <div class="site-legend-label">Plateau technique</div>
              </div>
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-collecte"></div>
                <div class="site-legend-label">Point de collecte</div>
              </div>
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-etablissement"></div>
                <div class="site-legend-label">Établissement de santé</div>
              </div>
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-ehpad"></div>
                <div class="site-legend-label">Ehpad</div>
              </div>
              <div class="site-legend-item">
                <div class="site-legend-color site-legend-color-veterinaire"></div>
                <div class="site-legend-label">Vétérinaire</div>
              </div>
            `;
          
          div.innerHTML = `
            <h4>Types de sites</h4>
            <div class="site-legend-items">
              ${legendItems}
              <div class="site-legend-item generated">
                <div class="site-legend-color" style="border: 2px dashed red; opacity: 0.6;"></div>
                <div class="site-legend-label">Coordonnées générées</div>
              </div>
            </div>
          `;
        };
        
        // Mettre à jour le contenu initial
        updateLegendContent();
        
        // Mettre à jour la légende lorsque les préférences changent
        const observer = new MutationObserver(() => {
          updateLegendContent();
        });
        
        return div;
      }
    });

    // Ajouter le contrôle à la carte
    const legendControl = new LegendControl();
    map.addControl(legendControl);

    return () => {
      map.removeControl(legendControl);
    };
  }, [map, markerPreferences]);

  return null;
};

// Composant pour les en-têtes de section dans le contrôle des couches
const SectionHeader: React.FC<{ title: string }> = ({ title }) => {
  const map = useMap();
  
  useEffect(() => {
    // Ajouter un style personnalisé après le rendu du composant
    const addCustomStyle = () => {
      const labels = document.querySelectorAll('.leaflet-control-layers-overlays label');
      
      labels.forEach(label => {
        const span = label.querySelector('span');
        if (span && span.textContent === title) {
          label.classList.add('layer-section-header');
          const checkbox = label.querySelector('input[type="checkbox"]') as HTMLInputElement;
          if (checkbox) {
            checkbox.disabled = true;
            checkbox.style.display = 'none';
          }
        }
      });
    };
    
    // Exécuter après un court délai pour s'assurer que le DOM est mis à jour
    setTimeout(addCustomStyle, 100);
    
    // Observer les changements dans le contrôle de couches
    const observer = new MutationObserver(addCustomStyle);
    const layersControl = document.querySelector('.leaflet-control-layers');
    
    if (layersControl) {
      observer.observe(layersControl, { childList: true, subtree: true });
    }
    
    return () => {
      observer.disconnect();
    };
  }, [title]);
  
  return <LayerGroup />;
};

// Composant pour ajouter le contrôle des libellés et des filtres personnalisés
const MapControls: React.FC<{
  showLabels: boolean,
  setShowLabels: (show: boolean) => void,
  sites: Site[],
  setSiteFilter: (filter: string | null) => void,
  currentFilter: string | null,
  showGeneratedCoordinates: boolean,
  setShowGeneratedCoordinates: (show: boolean) => void,
  onZoomToSite: (site: Site) => void
}> = ({ 
  showLabels, 
  setShowLabels, 
  sites, 
  setSiteFilter, 
  currentFilter,
  showGeneratedCoordinates,
  setShowGeneratedCoordinates,
  onZoomToSite
}) => {
  const map = useMap();
  const [searchTerm, setSearchTerm] = useState('');
  const [filtersVisible, setFiltersVisible] = useState(false);
  const [searchResults, setSearchResults] = useState<Site[]>([]);
  
  // Mettre à jour les résultats de recherche lorsque le terme de recherche change
  useEffect(() => {
    if (!searchTerm) {
      setSearchResults([]);
      return;
    }
    
    const normalizedSearch = searchTerm.toLowerCase();
    const results = sites.filter(site => 
      site.nom?.toLowerCase().includes(normalizedSearch) ||
      site.adresse?.toLowerCase().includes(normalizedSearch) ||
      site.ville?.toLowerCase().includes(normalizedSearch) ||
      site.codePostal?.includes(normalizedSearch) ||
      site.type?.toLowerCase().includes(normalizedSearch)
    ).slice(0, 5); // Limiter à 5 résultats
    
    setSearchResults(results);
  }, [searchTerm, sites]);
  
  useEffect(() => {
    // Créer un contrôle personnalisé
    const MapControlsControl = L.Control.extend({
      options: {
        position: 'topleft'
      },
      
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control map-custom-controls');
        
        // Bouton pour activer/désactiver les libellés
        const labelsButton = L.DomUtil.create('a', 'leaflet-control-labels', container);
        labelsButton.innerHTML = '<i class="fas fa-tag"></i>';
        labelsButton.href = '#';
        labelsButton.title = showLabels ? 'Masquer les libellés' : 'Afficher les libellés';
        labelsButton.setAttribute('role', 'button');
        labelsButton.setAttribute('aria-label', showLabels ? 'Masquer les libellés' : 'Afficher les libellés');
        
        if (showLabels) {
          labelsButton.classList.add('active');
        }
        
        L.DomEvent.on(labelsButton, 'click', function(e) {
          L.DomEvent.preventDefault(e);
          setShowLabels(!showLabels);
          labelsButton.title = !showLabels ? 'Masquer les libellés' : 'Afficher les libellés';
          labelsButton.classList.toggle('active');
        });
        
        // Créer un conteneur pour les filtres
        const filtersContainer = L.DomUtil.create('div', 'map-filters-container', container);
        filtersContainer.style.display = filtersVisible ? 'block' : 'none';
        
        // Ajouter un titre
        const filterTitle = L.DomUtil.create('div', 'map-filter-title', filtersContainer);
        filterTitle.textContent = 'Filtres';
        
        // Ajouter un champ de recherche
        const searchContainer = L.DomUtil.create('div', 'map-filter-search', filtersContainer);
        const searchInput = L.DomUtil.create('input', 'map-filter-search-input', searchContainer);
        searchInput.type = 'text';
        searchInput.placeholder = 'Rechercher un site...';
        searchInput.value = searchTerm;
        
        // Conteneur pour les résultats de recherche
        const searchResultsContainer = L.DomUtil.create('div', 'map-search-results', filtersContainer);
        searchResultsContainer.style.display = 'none';
        
        // Mettre à jour les résultats de recherche
        const updateSearchResults = () => {
          searchResultsContainer.innerHTML = '';
          
          if (searchResults.length === 0) {
            if (searchTerm) {
              searchResultsContainer.innerHTML = '<div class="map-search-no-results">Aucun résultat trouvé</div>';
              searchResultsContainer.style.display = 'block';
            } else {
              searchResultsContainer.style.display = 'none';
            }
            return;
          }
          
          searchResultsContainer.style.display = 'block';
          
          searchResults.forEach(site => {
            const resultItem = L.DomUtil.create('div', 'map-search-result-item', searchResultsContainer);
            resultItem.innerHTML = `
              <div class="map-search-result-name">${site.nom}</div>
              <div class="map-search-result-details">
                ${site.type ? `<span>${site.type}</span>` : ''}
                ${site.ville ? `<span>${site.ville}</span>` : ''}
              </div>
            `;
            
            L.DomEvent.on(resultItem, 'click', function() {
              onZoomToSite(site);
              searchResultsContainer.style.display = 'none';
              setSearchTerm('');
              searchInput.value = '';
            });
          });
        };
        
        // Mettre à jour les résultats initiaux
        updateSearchResults();
        
        // Mettre à jour les résultats lorsqu'ils changent
        const observer = new MutationObserver(() => {
          updateSearchResults();
        });
        
        L.DomEvent.on(searchInput, 'input', function(e) {
          setSearchTerm((e.target as HTMLInputElement).value);
          if ((e.target as HTMLInputElement).value) {
            setSiteFilter((e.target as HTMLInputElement).value);
          } else {
            setSiteFilter(null);
            searchResultsContainer.style.display = 'none';
          }
        });
        
        // Ajouter une option pour afficher/masquer les coordonnées générées
        const generatedCoordsContainer = L.DomUtil.create('div', 'map-filter-option', filtersContainer);
        const generatedCoordsCheckbox = L.DomUtil.create('input', '', generatedCoordsContainer);
        generatedCoordsCheckbox.type = 'checkbox';
        generatedCoordsCheckbox.id = 'show-generated-coords';
        generatedCoordsCheckbox.checked = showGeneratedCoordinates;
        
        const generatedCoordsLabel = L.DomUtil.create('label', '', generatedCoordsContainer);
        generatedCoordsLabel.htmlFor = 'show-generated-coords';
        generatedCoordsLabel.textContent = 'Afficher les coordonnées générées';
        
        L.DomEvent.on(generatedCoordsCheckbox, 'change', function(e) {
          setShowGeneratedCoordinates((e.target as HTMLInputElement).checked);
        });
        
        // Bouton pour afficher/masquer les filtres
        const filtersButton = L.DomUtil.create('a', 'leaflet-control-filters', container);
        filtersButton.innerHTML = '<i class="fas fa-filter"></i>';
        filtersButton.href = '#';
        filtersButton.title = 'Filtres avancés';
        filtersButton.setAttribute('role', 'button');
        filtersButton.setAttribute('aria-label', 'Filtres avancés');
        
        if (filtersVisible) {
          filtersButton.classList.add('active');
        }
        
        L.DomEvent.on(filtersButton, 'click', function(e) {
          L.DomEvent.preventDefault(e);
          setFiltersVisible(!filtersVisible);
          filtersContainer.style.display = filtersVisible ? 'block' : 'none';
          filtersButton.classList.toggle('active');
        });
        
        // Empêcher la propagation des événements pour éviter que la carte ne se déplace
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);
        
        return container;
      }
    });
    
    // Ajouter le contrôle à la carte
    const mapControlsControl = new MapControlsControl();
    map.addControl(mapControlsControl);
    
    return () => {
      map.removeControl(mapControlsControl);
    };
  }, [map, showLabels, setShowLabels, sites, setSiteFilter, currentFilter, searchTerm, filtersVisible, showGeneratedCoordinates, setShowGeneratedCoordinates, searchResults, onZoomToSite]);
  
  return null;
};

// Composant pour initialiser les événements des couches
const LayersEventInitializer: React.FC = () => {
  const map = useMap();
  
  useEffect(() => {
    // Initialiser le contrôle des couches
    const initLayersControl = () => {
      const layersControl = document.querySelector('.leaflet-control-layers');
      if (layersControl) {
        // S'assurer que toutes les cases à cocher sont cochées par défaut
        const checkboxes = layersControl.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          (checkbox as HTMLInputElement).checked = true;
        });
        
        // Déclencher un événement change sur chaque case à cocher pour activer les couches
        checkboxes.forEach(checkbox => {
          const event = new Event('change', { bubbles: true });
          (checkbox as HTMLInputElement).dispatchEvent(event);
        });
        
        // Ajouter des séparateurs visuels pour les sections
        const overlaysContainer = layersControl.querySelector('.leaflet-control-layers-overlays');
        if (overlaysContainer) {
          const labels = overlaysContainer.querySelectorAll('label');
          labels.forEach(label => {
            const text = label.textContent?.trim();
            if (text && text.startsWith('---')) {
              // Créer un élément de séparation
              const separator = document.createElement('div');
              separator.className = 'layer-section-header';
              separator.innerHTML = `<span>${text.replace(/^---\s*/, '')}</span>`;
              
              // Remplacer le label par le séparateur
              label.parentNode?.replaceChild(separator, label);
            }
          });
        }
      } else {
        // Si le contrôle n'est pas encore disponible, réessayer plus tard
        setTimeout(initLayersControl, 100);
      }
    };
    
    // Attendre que la carte soit chargée avant d'initialiser le contrôle des couches
    setTimeout(initLayersControl, 500);
    
    return () => {
      // Nettoyer les écouteurs d'événements si nécessaire
    };
  }, [map]);
  
  return null;
};

// Composant pour corriger manuellement les coordonnées d'un site
const ManualCoordinatesCorrection: React.FC<{
  sites: Site[];
  onCoordinatesUpdated: (siteId: string, latitude: number, longitude: number) => void;
}> = ({ sites, onCoordinatesUpdated }) => {
  const map = useMap();
  const [isActive, setIsActive] = useState(false);
  const [selectedSite, setSelectedSite] = useState<Site | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [searchResults, setSearchResults] = useState<Site[]>([]);
  const markerRef = useRef<L.Marker | null>(null);
  
  // Filtrer les sites en fonction du terme de recherche
  useEffect(() => {
    if (!searchTerm) {
      setSearchResults([]);
      return;
    }
    
    const normalizedSearch = searchTerm.toLowerCase();
    const results = sites.filter(site => 
      site.nom?.toLowerCase().includes(normalizedSearch) ||
      site.adresse?.toLowerCase().includes(normalizedSearch) ||
      site.ville?.toLowerCase().includes(normalizedSearch) ||
      site.codePostal?.includes(normalizedSearch)
    ).slice(0, 10); // Limiter à 10 résultats
    
    setSearchResults(results);
  }, [searchTerm, sites]);
  
  // Fonction pour sélectionner un site
  const selectSite = (site: Site) => {
    setSelectedSite(site);
    setSearchTerm('');
    setSearchResults([]);
    
    if (site.latitude && site.longitude) {
      // Centrer la carte sur le site
      map.setView([site.latitude, site.longitude], 15);
      
      // Créer un marqueur déplaçable
      if (markerRef.current) {
        map.removeLayer(markerRef.current);
      }
      
      const marker = L.marker([site.latitude, site.longitude], {
        draggable: true,
        icon: L.divIcon({
          className: 'correction-marker',
          html: `<div style="background-color: red; width: 24px; height: 24px; border-radius: 50%; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);">
                  <i class="fas fa-map-marker-alt" style="color: white; font-size: 14px;"></i>
                </div>`,
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        })
      }).addTo(map);
      
      // Ajouter un popup avec les informations du site
      marker.bindPopup(`
        <div>
          <strong>${site.nom}</strong><br>
          ${site.adresse}<br>
          ${site.codePostal} ${site.ville || ''}
        </div>
      `).openPopup();
      
      // Mettre à jour les coordonnées lorsque le marqueur est déplacé
      marker.on('dragend', (e) => {
        const newLatLng = marker.getLatLng();
        console.log(`Nouvelles coordonnées pour ${site.nom}: Lat=${newLatLng.lat}, Lng=${newLatLng.lng}`);
      });
      
      markerRef.current = marker;
    } else {
      alert(`Le site "${site.nom}" n'a pas de coordonnées. Veuillez d'abord le géocoder.`);
    }
  };
  
  // Fonction pour enregistrer les nouvelles coordonnées
  const saveCoordinates = () => {
    if (selectedSite && markerRef.current) {
      const newLatLng = markerRef.current.getLatLng();
      onCoordinatesUpdated(selectedSite.id, newLatLng.lat, newLatLng.lng);
      
      // Afficher un message de confirmation
      alert(`Les coordonnées du site "${selectedSite.nom}" ont été mises à jour.`);
      
      // Réinitialiser
      map.removeLayer(markerRef.current);
      markerRef.current = null;
      setSelectedSite(null);
      setIsActive(false);
    }
  };
  
  // Fonction pour annuler la correction
  const cancelCorrection = () => {
    if (markerRef.current) {
      map.removeLayer(markerRef.current);
      markerRef.current = null;
    }
    
    setSelectedSite(null);
    setIsActive(false);
  };
  
  useEffect(() => {
    // Créer un contrôle personnalisé
    const CorrectionControl = L.Control.extend({
      options: {
        position: 'topleft'
      },
      
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control correction-control');
        
        if (!isActive) {
          // Bouton pour activer la correction
          const button = L.DomUtil.create('a', 'correction-button', container);
          button.innerHTML = '<i class="fas fa-map-marker-alt"></i>';
          button.href = '#';
          button.title = 'Corriger les coordonnées d\'un site';
          
          L.DomEvent.on(button, 'click', function(e) {
            L.DomEvent.preventDefault(e);
            setIsActive(true);
          });
        } else {
          // Interface de correction
          const correctionPanel = L.DomUtil.create('div', 'correction-panel', container);
          
          // Titre
          const title = L.DomUtil.create('div', 'correction-title', correctionPanel);
          title.textContent = 'Correction de coordonnées';
          
          // Champ de recherche
          const searchContainer = L.DomUtil.create('div', 'correction-search', correctionPanel);
          const searchInput = L.DomUtil.create('input', 'correction-search-input', searchContainer);
          searchInput.type = 'text';
          searchInput.placeholder = 'Rechercher un site...';
          searchInput.value = searchTerm;
          
          L.DomEvent.on(searchInput, 'input', function(e) {
            setSearchTerm((e.target as HTMLInputElement).value);
          });
          
          // Résultats de recherche
          if (searchResults.length > 0) {
            const resultsContainer = L.DomUtil.create('div', 'correction-results', correctionPanel);
            
            searchResults.forEach(site => {
              const resultItem = L.DomUtil.create('div', 'correction-result-item', resultsContainer);
              resultItem.textContent = site.nom;
              
              L.DomEvent.on(resultItem, 'click', function() {
                selectSite(site);
              });
            });
          }
          
          // Site sélectionné
          if (selectedSite) {
            const selectedContainer = L.DomUtil.create('div', 'correction-selected', correctionPanel);
            
            const siteInfo = L.DomUtil.create('div', 'correction-site-info', selectedContainer);
            siteInfo.innerHTML = `
              <strong>${selectedSite.nom}</strong><br>
              ${selectedSite.adresse}<br>
              ${selectedSite.codePostal} ${selectedSite.ville || ''}
            `;
            
            const instructions = L.DomUtil.create('div', 'correction-instructions', selectedContainer);
            instructions.textContent = 'Déplacez le marqueur rouge à la position correcte, puis cliquez sur "Enregistrer".';
            
            const buttonsContainer = L.DomUtil.create('div', 'correction-buttons', selectedContainer);
            
            const saveButton = L.DomUtil.create('button', 'correction-save-button', buttonsContainer);
            saveButton.textContent = 'Enregistrer';
            
            L.DomEvent.on(saveButton, 'click', function() {
              saveCoordinates();
            });
            
            const cancelButton = L.DomUtil.create('button', 'correction-cancel-button', buttonsContainer);
            cancelButton.textContent = 'Annuler';
            
            L.DomEvent.on(cancelButton, 'click', function() {
              cancelCorrection();
            });
          }
          
          // Bouton pour fermer le panneau
          if (!selectedSite) {
            const closeButton = L.DomUtil.create('button', 'correction-close-button', correctionPanel);
            closeButton.textContent = 'Fermer';
            
            L.DomEvent.on(closeButton, 'click', function() {
              setIsActive(false);
            });
          }
        }
        
        // Empêcher la propagation des événements pour éviter que la carte ne se déplace
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);
        
        return container;
      }
    });
    
    // Ajouter le contrôle à la carte
    const correctionControl = new CorrectionControl();
    map.addControl(correctionControl);
    
    return () => {
      map.removeControl(correctionControl);
      
      if (markerRef.current) {
        map.removeLayer(markerRef.current);
        markerRef.current = null;
      }
    };
  }, [map, isActive, searchTerm, searchResults, selectedSite, sites, onCoordinatesUpdated]);
  
  return null;
};

const MapView: React.FC = () => {
  const [courierLocations, setCourierLocations] = useState<CourierLocation[]>([]);
  const [sites, setSites] = useState<Site[]>([]);
  const [tournees, setTournees] = useState<Tournee[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [geocodingStatus, setGeocodingStatus] = useState<string | null>(null);
  const [isGeocoding, setIsGeocoding] = useState(false);
  const [showGeneratedCoordinates, setShowGeneratedCoordinates] = useState(true);
  const [markerPreferences, setMarkerPreferences] = useState<MarkerPreference[]>([]);
  const [showLabels, setShowLabels] = useState(false);
  const [siteFilter, setSiteFilter] = useState<string | null>(null);
  const mapContainerRef = useRef<HTMLDivElement>(null);
  const markersRef = useRef<{[key: string]: L.Marker}>({});
  const layerGroupRef = useRef<L.LayerGroup | null>(null);
  const mapRef = useRef<L.Map | null>(null);
  
  useEffect(() => {
    // Récupérer les sites et les tournées
    const unsubscribeSites = fetchSites();
    const unsubscribeTournees = fetchTournees();
    
    // Récupérer les préférences de marqueurs
    fetchMarkerPreferences();
    
    // Nettoyer les abonnements
    return () => {
      unsubscribeSites();
      unsubscribeTournees();
    };
  }, []);

  // Nouvel effet pour gérer l'écouteur des passages
  useEffect(() => {
    const unsubscribePassages = setupRealTimeListener();
    return () => {
      if (unsubscribePassages) unsubscribePassages();
    };
  }, [sites, tournees]); // Ajouter les dépendances nécessaires

  // Modifier fetchSites pour utiliser onSnapshot au lieu de getDocs
  const fetchSites = () => {
    try {
      const sitesRef = collection(db, 'sites');
      return onSnapshot(sitesRef, (snapshot) => {
        const sitesData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Site[];
        
        // Vérifier combien de sites ont des coordonnées
        const sitesWithCoordinates = sitesData.filter(site => 
          site.latitude && site.longitude
        );
        
        console.log(`${sitesWithCoordinates.length} sites sur ${sitesData.length} ont des coordonnées géographiques.`);
        
        // Afficher les types de sites pour le débogage
        const typeCounts = sitesData.reduce((acc, site) => {
          const type = site.type || 'Non spécifié';
          acc[type] = (acc[type] || 0) + 1;
          return acc;
        }, {} as Record<string, number>);
        
        console.log('Répartition des types de sites:', typeCounts);
        
        setSites(sitesData);
      }, (error) => {
        console.error('Erreur lors de la récupération des sites:', error);
        setError('Erreur lors de la récupération des sites');
      });
    } catch (error) {
      console.error('Erreur lors de la configuration de l\'écouteur des sites:', error);
      setError('Erreur lors de la configuration de l\'écouteur des sites');
      return () => {};
    }
  };

  // Modifier fetchTournees pour utiliser onSnapshot au lieu de getDocs
  const fetchTournees = () => {
    try {
      const tourneesRef = collection(db, 'tournees');
      return onSnapshot(tourneesRef, (snapshot) => {
        const tourneesData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Tournee[];
        
        setTournees(tourneesData);
      }, (error) => {
        console.error('Erreur lors de la récupération des tournées:', error);
        setError('Erreur lors de la récupération des tournées');
      });
    } catch (error) {
      console.error('Erreur lors de la configuration de l\'écouteur des tournées:', error);
      setError('Erreur lors de la configuration de l\'écouteur des tournées');
      return () => {};
    }
  };

  // Modifier setupRealTimeListener pour utiliser les sites et tournées à jour
  const setupRealTimeListener = useCallback(() => {
    try {
      const passagesRef = collection(db, 'passages');
      const passagesQuery = query(passagesRef, where('statut', '==', 'En cours'));
      
      return onSnapshot(passagesQuery, async (snapshot) => {
        setLoading(true);
        
        const locations: CourierLocation[] = [];
        const changes = snapshot.docChanges();
        
        // Log des changements uniquement en mode développement et seulement une fois
        if (import.meta.env.DEV && changes.length > 0) {
          // Utiliser un log plus discret
          console.debug(`MapView: ${changes.length} changement(s) détecté(s)`);
        }
        
        for (const doc of snapshot.docs) {
          const passage = doc.data();
          const isArrival = !!(passage.siteArrivee && passage.dateHeureArrivee);
          const siteId = isArrival ? passage.siteArrivee : passage.siteDepart;
          const site = sites.find(s => s.id === siteId);
          
          if (site && site.latitude && site.longitude) {
            const tourneeId = passage.tourneeId;
            const tournee = tournees.find(t => t.id === tourneeId);
            const lastScan = isArrival ? passage.dateHeureArrivee : passage.dateHeureDepart;
            
            locations.push({
              id: doc.id,
              nom: passage.coursierChargement || 'Coursier inconnu',
              tourneeId: tourneeId || '',
              tourneeName: tournee?.nom || 'Tournée inconnue',
              siteId: siteId,
              siteName: site.nom,
              latitude: site.latitude,
              longitude: site.longitude,
              lastScan: lastScan,
              isArrival: isArrival
            });
          }
        }
        
        // Mettre à jour les marqueurs et l'état
        setCourierLocations(locations);
        setLoading(false);
      }, (error) => {
        console.error('Erreur lors de l\'écoute des passages:', error);
        setError('Erreur lors de l\'écoute des passages');
        setLoading(false);
      });
    } catch (error) {
      console.error('Erreur lors de la configuration de l\'écouteur en temps réel:', error);
      setError('Erreur lors de la configuration de l\'écouteur en temps réel');
      setLoading(false);
      return () => {};
    }
  }, [sites, tournees]); // Ajouter les dépendances au useCallback

  // Formater la date pour l'affichage
  const formatDate = (timestamp: any): string => {
    if (!timestamp) return 'Date inconnue';
    
    try {
      // Gérer différents types de timestamp (Firestore Timestamp ou string)
      let date;
      if (typeof timestamp === 'string') {
        date = new Date(timestamp);
      } else if (timestamp.toDate && typeof timestamp.toDate === 'function') {
        // C'est un Timestamp Firestore
        date = timestamp.toDate();
      } else {
        date = new Date(timestamp);
      }
      
      // Formater la date
      return date.toLocaleString('fr-FR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    } catch (error) {
      console.error('Erreur lors du formatage de la date:', error);
      return 'Date invalide';
    }
  };

  // Fonction pour géocoder manuellement tous les sites
  const geocodeAllSites = async () => {
    try {
      setIsGeocoding(true);
      setGeocodingStatus('Préparation du géocodage...');
      
      // Filtrer les sites sans coordonnées
      const sitesWithoutCoordinates = sites.filter(site => 
        !site.latitude || !site.longitude
      );
      
      if (sitesWithoutCoordinates.length === 0) {
        setGeocodingStatus('Tous les sites ont déjà des coordonnées géographiques.');
        setTimeout(() => {
          setGeocodingStatus(null);
          setIsGeocoding(false);
        }, 3000);
        return;
      }
      
      setGeocodingStatus(`Géocodage de ${sitesWithoutCoordinates.length} sites...`);
      console.log(`Début du géocodage pour ${sitesWithoutCoordinates.length} sites`);
      
      // Géocoder les sites sans coordonnées
      const updatedSites = [...sites];
      let geocodedCount = 0;
      let horairesCount = 0; // Compteur pour les sites avec horaires récupérés
      
      for (const site of sitesWithoutCoordinates) {
        if (site.adresse && (site.ville || site.codePostal)) {
          try {
            console.log(`Tentative de géocodage pour le site: ${site.nom}, Adresse: ${site.adresse}, ${site.codePostal} ${site.ville}`);
            
            const result = await geocodeAddress(
              site.nom || '',
              site.adresse || '',
              site.ville || '',
              site.codePostal || ''
            );
            
            if (result) {
              console.log(`Géocodage réussi pour ${site.nom}: Lat=${result.latitude}, Lon=${result.longitude}`);
              
              // Préparer les données à mettre à jour
              const updateData: any = {
                latitude: result.latitude,
                longitude: result.longitude
              };
              
              // Ajouter les horaires d'ouverture si disponibles
              if (result.horairesLV) {
                updateData.horairesLV = result.horairesLV;
                console.log(`Horaires L-V récupérés pour "${site.nom}": ${result.horairesLV}`);
              }
              
              if (result.horairesSamedi) {
                updateData.horairesSamedi = result.horairesSamedi;
                console.log(`Horaires Samedi récupérés pour "${site.nom}": ${result.horairesSamedi}`);
              }
              
              // Compter les sites pour lesquels des horaires ont été récupérés
              if (result.horairesLV || result.horairesSamedi) {
                horairesCount++;
              }
              
              // Mettre à jour les données dans Firestore
              const siteRef = doc(db, 'sites', site.id);
              await updateDoc(siteRef, updateData);
              
              // Mettre à jour les données dans l'état local
              const index = updatedSites.findIndex(s => s.id === site.id);
              if (index !== -1) {
                updatedSites[index] = {
                  ...updatedSites[index],
                  ...updateData
                };
              }
              
              geocodedCount++;
              setGeocodingStatus(`Géocodage en cours... ${geocodedCount}/${sitesWithoutCoordinates.length}`);
            } else {
              console.log(`Échec du géocodage pour ${site.nom}`);
            }
          } catch (error) {
            console.error(`Erreur lors du géocodage du site ${site.nom}:`, error);
          }
          
          // Pause pour éviter de dépasser les limites de l'API
          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          console.log(`Site ${site.nom} sans adresse complète, géocodage impossible`);
        }
      }
      
      if (geocodedCount > 0) {
        console.log(`${geocodedCount} sites géocodés avec succès, dont ${horairesCount} avec horaires.`);
        setSites(updatedSites);
        setGeocodingStatus(`${geocodedCount} sites géocodés avec succès, dont ${horairesCount} avec horaires récupérés.`);
      } else {
        setGeocodingStatus('Aucun site n\'a pu être géocodé. Vérifiez que les adresses sont complètes.');
      }
      
      // Masquer le statut après quelques secondes
      setTimeout(() => {
        setGeocodingStatus(null);
        setIsGeocoding(false);
      }, 5000);
    } catch (error) {
      console.error('Erreur lors du géocodage des sites:', error);
      setError('Erreur lors du géocodage des sites');
      setIsGeocoding(false);
    }
  };

  // Fonction pour attribuer automatiquement des types et des pôles aux sites
  const assignTypesAndPoles = async () => {
    try {
      setIsGeocoding(true);
      setGeocodingStatus('Préparation de la mise à jour des sites...');
      
      // Filtrer les sites sans type ou sans pôle
      const sitesWithoutType = sites.filter(site => !site.type);
      const sitesWithoutPole = sites.filter(site => !site.pole);
      
      if (sitesWithoutType.length === 0 && sitesWithoutPole.length === 0) {
        setGeocodingStatus('Tous les sites ont déjà un type et un pôle définis.');
        setTimeout(() => {
          setGeocodingStatus(null);
          setIsGeocoding(false);
        }, 3000);
        return;
      }
      
      setGeocodingStatus(`Mise à jour de ${sitesWithoutType.length + sitesWithoutPole.length} sites...`);
      
      // Mettre à jour les sites sans type
      const updatedSites = [...sites];
      let updatedCount = 0;
      
      // Attribuer des types aux sites qui n'en ont pas
      for (const site of sitesWithoutType) {
        try {
          // Attribuer un type aléatoire
          const randomType = SITE_TYPES[Math.floor(Math.random() * SITE_TYPES.length)];
          
          // Mettre à jour le type dans Firestore
          const siteRef = doc(db, 'sites', site.id);
          await updateDoc(siteRef, {
            type: randomType
          });
          
          // Mettre à jour le type dans l'état local
          const index = updatedSites.findIndex(s => s.id === site.id);
          if (index !== -1) {
            updatedSites[index] = {
              ...updatedSites[index],
              type: randomType
            };
          }
          
          updatedCount++;
          setGeocodingStatus(`Mise à jour en cours... ${updatedCount}/${sitesWithoutType.length + sitesWithoutPole.length}`);
        } catch (error) {
          console.error(`Erreur lors de la mise à jour du type du site ${site.nom}:`, error);
        }
      }
      
      // Attribuer des pôles aux sites qui n'en ont pas
      for (const site of sitesWithoutPole) {
        try {
          // Attribuer un pôle aléatoire
          const randomPole = POLES[Math.floor(Math.random() * POLES.length)];
          
          // Mettre à jour le pôle dans Firestore
          const siteRef = doc(db, 'sites', site.id);
          await updateDoc(siteRef, {
            pole: randomPole
          });
          
          // Mettre à jour le pôle dans l'état local
          const index = updatedSites.findIndex(s => s.id === site.id);
          if (index !== -1) {
            updatedSites[index] = {
              ...updatedSites[index],
              pole: randomPole
            };
          }
          
          updatedCount++;
          setGeocodingStatus(`Mise à jour en cours... ${updatedCount}/${sitesWithoutType.length + sitesWithoutPole.length}`);
        } catch (error) {
          console.error(`Erreur lors de la mise à jour du pôle du site ${site.nom}:`, error);
        }
      }
      
      if (updatedCount > 0) {
        console.log(`${updatedCount} sites mis à jour avec succès.`);
        setSites(updatedSites);
        setGeocodingStatus(`${updatedCount} sites mis à jour avec succès.`);
      } else {
        setGeocodingStatus('Aucun site n\'a pu être mis à jour.');
      }
      
      // Masquer le statut après quelques secondes
      setTimeout(() => {
        setGeocodingStatus(null);
        setIsGeocoding(false);
      }, 3000);
    } catch (error) {
      console.error('Erreur lors de la mise à jour des sites:', error);
      setError('Erreur lors de la mise à jour des sites');
      setIsGeocoding(false);
    }
  };

  // Fonction pour vérifier et mettre à jour les types et pôles des sites
  const checkSiteTypesAndPoles = () => {
    // Vérifier si les types de sites sont définis
    if (!SITE_TYPES || SITE_TYPES.length === 0) {
      console.warn('Aucun type de site défini');
    }
    
    // Vérifier si les pôles sont définis
    if (!POLES || POLES.length === 0) {
      console.warn('Aucun pôle défini');
    }
    
    return null;
  };

  // Calculer le nombre de sites avec et sans coordonnées
  const sitesWithCoordinates = sites.filter(site => site.latitude && site.longitude);
  const sitesWithoutCoordinates = sites.filter(site => !site.latitude || !site.longitude);

  // Fonction pour récupérer les préférences de marqueurs
  const fetchMarkerPreferences = async () => {
    try {
      const preferencesRef = collection(db, 'markerPreferences');
      const snapshot = await getDocs(preferencesRef);
      
      if (snapshot.empty) {
        console.log('Aucune préférence de marqueur trouvée, utilisation des valeurs par défaut');
        return;
      }
      
      const preferencesData = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as MarkerPreference[];
      
      setMarkerPreferences(preferencesData);
      console.log(`${preferencesData.length} préférences de marqueurs chargées`);
      
    } catch (error) {
      console.error('Erreur lors de la récupération des préférences de marqueurs:', error);
    }
  };
  
  // Configurer un écouteur pour les changements dans les préférences de marqueurs
  useEffect(() => {
    try {
      const preferencesRef = collection(db, 'markerPreferences');
      const unsubscribe = onSnapshot(preferencesRef, (snapshot) => {
        const preferencesData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as MarkerPreference[];
        
        setMarkerPreferences(preferencesData);
        console.log(`Mise à jour des préférences de marqueurs: ${preferencesData.length} préférences chargées`);
      });
      
      return () => unsubscribe();
    } catch (error) {
      console.error('Erreur lors de la configuration de l\'écouteur des préférences de marqueurs:', error);
      return () => {};
    }
  }, []);

  // Fonction pour obtenir l'icône en fonction du type de site et des préférences
  const getIconForSiteType = (type: string | undefined, site?: Site): L.Icon => {
    if (!type) return siteIcon;
    
    // Normaliser le type pour la comparaison
    const normalizedType = normalizeType(type);
    
    // Récupérer la préférence de marqueur pour ce type de site
    const preference = markerPreferences.find(pref => 
      normalizeType(pref.siteType) === normalizedType
    );
    
    // Si une préférence existe, créer une icône personnalisée
    if (preference) {
      // Créer une icône personnalisée avec la couleur spécifiée
      const customIcon = L.divIcon({
        className: 'custom-div-icon',
        html: `
          <div style="background-color: ${preference.color}; width: 24px; height: 24px; border-radius: 50%; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);">
            <i class="fas ${getIconClassForType(preference.icon)}" style="color: white; font-size: 14px;"></i>
          </div>
          ${showLabels && site ? `<div class="marker-label">${site.nom}</div>` : ''}
        `,
        iconSize: showLabels ? [120, 40] : [24, 24],
        iconAnchor: [12, 12],
        popupAnchor: [0, -12]
      });
      
      return customIcon as unknown as L.Icon;
    }
    
    // Si aucune préférence n'est trouvée, utiliser les icônes par défaut
    return getDefaultIconForSiteType(type);
  };

  // Fonction pour obtenir la classe d'icône FontAwesome en fonction du type
  const getIconClassForType = (iconType: string): string => {
    switch (iconType) {
      case 'droplet':
        return 'fa-tint';
      case 'circle':
        return 'fa-circle';
      case 'square':
        return 'fa-square';
      case 'triangle':
        return 'fa-exclamation-triangle';
      case 'star':
        return 'fa-star';
      case 'pin':
        return 'fa-map-marker-alt';
      default:
        return 'fa-tint';
    }
  };

  // Filtrer les sites en fonction du terme de recherche
  const filteredSites = useMemo(() => {
    if (!siteFilter) return sites;
    
    const normalizedFilter = siteFilter.toLowerCase();
    return sites.filter(site => 
      site.nom?.toLowerCase().includes(normalizedFilter) ||
      site.adresse?.toLowerCase().includes(normalizedFilter) ||
      site.ville?.toLowerCase().includes(normalizedFilter) ||
      site.codePostal?.includes(normalizedFilter) ||
      site.type?.toLowerCase().includes(normalizedFilter)
    );
  }, [sites, siteFilter]);

  // Fonction pour zoomer sur un site spécifique
  const handleZoomToSite = useCallback((site: Site) => {
    if (!site.latitude || !site.longitude || !mapRef.current) return;
    
    mapRef.current.setView([site.latitude, site.longitude], 15);
    
    // Créer un marqueur temporaire pour indiquer le site
    const tempMarker = L.marker([site.latitude, site.longitude], {
      icon: L.divIcon({
        className: 'temp-marker',
        html: '<div class="pulse"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      })
    }).addTo(mapRef.current);
    
    // Supprimer le marqueur après quelques secondes
    setTimeout(() => {
      if (mapRef.current) {
        mapRef.current.removeLayer(tempMarker);
      }
    }, 3000);
  }, [mapRef]);
  
  // Composant pour obtenir la référence à la carte
  const MapReference: React.FC = () => {
    const map = useMap();
    
    useEffect(() => {
      mapRef.current = map;
    }, [map]);
    
    return null;
  };

  // Fonction pour mettre à jour les coordonnées
  const handleCoordinatesUpdate = async (siteId: string, latitude: number, longitude: number) => {
    try {
      // Mettre à jour les coordonnées dans Firestore
      const siteRef = doc(db, 'sites', siteId);
      await updateDoc(siteRef, {
        latitude,
        longitude
      });
      
      // Mettre à jour les coordonnées dans l'état local
      const updatedSites = sites.map(site => {
        if (site.id === siteId) {
          return {
            ...site,
            latitude,
            longitude
          };
        }
        return site;
      });
      
      setSites(updatedSites);
      console.log(`Coordonnées mises à jour pour le site ${siteId}: Lat=${latitude}, Lon=${longitude}`);
    } catch (error) {
      console.error('Erreur lors de la mise à jour des coordonnées:', error);
      setError('Erreur lors de la mise à jour des coordonnées');
    }
  };

  return (
    <div className="map-view-container">
      <h1>Carte des coursiers en temps réel</h1>
      
      {error && (
        <div className="error-message">
          {error}
        </div>
      )}
      
      {geocodingStatus && (
        <div className="geocoding-status">
          {geocodingStatus}
        </div>
      )}
      
      {loading && courierLocations.length === 0 && !geocodingStatus && (
        <div className="loading-spinner">
          Chargement de la carte...
        </div>
      )}
      
      {checkSiteTypesAndPoles()}
      
      <div className="map-actions">
        <button 
          className="map-action-button"
          onClick={geocodeAllSites}
          disabled={isGeocoding}
        >
          <i className="fas fa-map-marker-alt"></i> Géocoder tous les sites
        </button>
        
        <button 
          className="map-action-button"
          onClick={() => {
            const message = `
              Pour corriger manuellement les coordonnées d'un site :
              1. Cliquez sur l'icône de marqueur rouge dans le coin supérieur gauche de la carte
              2. Recherchez le site à corriger
              3. Déplacez le marqueur à la position correcte
              4. Cliquez sur "Enregistrer"
            `;
            alert(message);
          }}
        >
          <i className="fas fa-info-circle"></i> Aide correction manuelle
        </button>
      </div>
      
      <div className="map-container" ref={mapContainerRef}>
        <MapContainer 
          center={franceCenter}
          zoom={6}
          style={{ height: '100%', width: '100%' }}
          preferCanvas={true}
        >
          <MapReference />
          <TileLayer
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          />
          
          <FullscreenControl />
          <SiteLegend />
          <MapControls 
            showLabels={showLabels} 
            setShowLabels={setShowLabels} 
            sites={sites} 
            setSiteFilter={setSiteFilter} 
            currentFilter={siteFilter}
            showGeneratedCoordinates={showGeneratedCoordinates}
            setShowGeneratedCoordinates={setShowGeneratedCoordinates}
            onZoomToSite={handleZoomToSite}
          />
          
          <ManualCoordinatesCorrection 
            sites={sites}
            onCoordinatesUpdated={handleCoordinatesUpdate}
          />
          
          {/* Contrôle des couches */}
          <LayersControl position="topright">
            {/* Fonds de carte */}
            <LayersControl.BaseLayer checked name="OpenStreetMap">
              <TileLayer
                url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
              />
            </LayersControl.BaseLayer>
            <LayersControl.BaseLayer name="Satellite">
              <TileLayer
                url="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
                attribution='&copy; <a href="https://www.esri.com">Esri</a>'
              />
            </LayersControl.BaseLayer>
            
            {/* Couches de sites */}
            <LayersControl.Overlay checked name="Tous les sites">
              <AllSitesLayer 
                sites={siteFilter ? filteredSites : sites} 
                icon={siteIcon} 
                getIconForSiteType={getIconForSiteType}
                showLabels={showLabels}
                showGeneratedCoordinates={showGeneratedCoordinates}
              />
            </LayersControl.Overlay>
            
            {/* Séparateur pour les types de sites */}
            <LayersControl.Overlay checked name="--- TYPES DE SITES ---">
              <div />
            </LayersControl.Overlay>
            
            {/* Couches par type de site */}
            {SITE_TYPES.map(type => (
              <LayersControl.Overlay checked key={type} name={type}>
                <SiteTypeLayer 
                  sites={siteFilter ? filteredSites : sites} 
                  icon={siteIcon} 
                  type={type}
                  getIconForSiteType={getIconForSiteType}
                  showLabels={showLabels}
                  showGeneratedCoordinates={showGeneratedCoordinates}
                />
              </LayersControl.Overlay>
            ))}
            
            {/* Séparateur pour les pôles */}
            <LayersControl.Overlay checked name="--- PÔLES ---">
              <div />
            </LayersControl.Overlay>
            
            {/* Couches par pôle */}
            {POLES.map(pole => (
              <LayersControl.Overlay checked key={pole} name={`Pôle ${pole}`}>
                <PoleLayer 
                  sites={siteFilter ? filteredSites : sites} 
                  icon={siteIcon} 
                  pole={pole}
                  getIconForSiteType={getIconForSiteType}
                  showLabels={showLabels}
                  showGeneratedCoordinates={showGeneratedCoordinates}
                />
              </LayersControl.Overlay>
            ))}
            
            {/* Séparateur pour les coursiers */}
            <LayersControl.Overlay checked name="--- COURSIERS ---">
              <div />
            </LayersControl.Overlay>
            
            {/* Couche des coursiers */}
            <LayersControl.Overlay checked name="Coursiers">
              <CouriersLayer 
                courierLocations={courierLocations} 
                departIcon={departIcon} 
                arrivalIcon={arrivalIcon}
                formatDate={formatDate}
              />
            </LayersControl.Overlay>
          </LayersControl>
          
          {/* Ajouter le composant d'initialisation des événements des couches */}
          <LayersEventInitializer />
        </MapContainer>
      </div>
      
      <div className="courier-list">
        <h2>Coursiers actifs ({courierLocations.length})</h2>
        {courierLocations.length === 0 ? (
          <p>Aucun coursier actif pour le moment</p>
        ) : (
          <ul>
            {courierLocations.map(courier => (
              <li 
                key={courier.id} 
                className={`courier-item ${courier.isArrival ? 'courier-arrival' : 'courier-departure'}`}
              >
                <div className="courier-name">{courier.nom}</div>
                <div className="courier-details">
                  <span>Tournée: {courier.tourneeName}</span>
                  <span>Dernier scan: {formatDate(courier.lastScan)}</span>
                  <span>Site: {courier.siteName}</span>
                  <span className="courier-status">Statut: {courier.isArrival ? 'Arrivée' : 'Départ'}</span>
                </div>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
};

// Ajouter la méthode slideTo à L.Marker
declare module 'leaflet' {
  interface Marker {
    slideTo(latlng: L.LatLng, options?: { duration?: number; keepAtCenter?: boolean }): void;
  }
}

L.Marker.prototype.slideTo = function(latlng: L.LatLng, options: { duration?: number; keepAtCenter?: boolean } = {}) {
  const duration = options.duration || 1000;
  const keepAtCenter = options.keepAtCenter || false;
  
  const start = this.getLatLng();
  const startTime = performance.now();
  
  const animate = (currentTime: number) => {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    const lat = start.lat + (latlng.lat - start.lat) * progress;
    const lng = start.lng + (latlng.lng - start.lng) * progress;
    
    this.setLatLng([lat, lng]);
    
    if (keepAtCenter) {
      this._map?.setView([lat, lng]);
    }
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  };
  
  requestAnimationFrame(animate);
};

export default MapView; 
